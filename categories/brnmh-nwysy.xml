<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>شاهینیسم (برنامه نویسی)</title><link>http://shahinism.github.io</link><description>بعضی وقت‌ها باید قبل از این که بتوانید راه بروید‌، بدوید‌!</description><lastBuildDate>Fri, 24 May 2013 15:57:54 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>این ایمکس دوست داشتنی (بالانس کردن پرانتز‌ها)</title><link>http://shahinism.github.io/posts/blog13920127yn-ymkhs-dwst-dshtny-blns-khrdn-prn.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از دلایل اصلی Syntax error‌ها بالانس نبودن پرانتز‌هاست (منظورم پرانتز‌، کروشه‌، آکولاد‌، &amp;lt;&amp;gt;‌، گیومه و … است). خوب از آن‌جایی که بنیاد ایمکس براساس Lisp است و Lisp به خاطر پرانتز‌هایش معروف شده (خیلی‌ها به شوخی می‌گن که Lisp مخفف Lost in stupid parentheses هست)‌، مطمئنا باید راهی برای حل این مشکل داشته باشد.
برای این کار خطوط زیر را داخل ‎.emacs وارد می‌کنیم:&lt;/p&gt;


&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;electric-pair-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;show-paren-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب با خط اول‌، به ایمکس می‌گوییم‌، هر وقت ما پرانتزی (که شامل تمام علاماتی است که در بالا اشاره کردیم) باز کردیم‌، خودت به صورت خودکار‌، کاراکتر بستن آن را وارد کن. همین‌طور در خط دوم مجبورش می‌کنیم وقتی روی پرانتزی هستیم‌، اگر جفتی برایش وجود دارد‌، آن را برایمان نمایش دهد (هر دو طرف پرانتز سبز می‌شود معمولا‌. با توجه به تنظیمات پوستهٔ ایمکس)‌. اگر نه‌، سمتی که رویش ایستاده‌ایم را قرمز کن تا بفهمیم تنهاست ;-)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dl.dropboxusercontent.com/u/25017694/Blog-photos/emacsparenmatch.png"&gt;&lt;img alt="نمونه‌ای از نمایش جفت پرانتز در ایمکس" src="https://dl.dropboxusercontent.com/u/25017694/Blog-photos/emacsparenmatch.png" width="328" height="42"&gt;&lt;/a&gt; نمونه‌ای از نمایش جفت پرانتز در ایمکس&lt;/p&gt;
&lt;p&gt;بخش اول کار که معلوم است. ولی این بخش دوم قابلیت‌های جالب دیگری هم دارد. مثلا می‌توان با(setq show-paren-delay 0) میزان زمانی که طول می‌کشد تا جفت کاراکتر پرانتزمان را نمایش دهد را تعیین کنیم. از قرار به طور پیش‌فرض مقداری Delay تعیین شده که ما با این دستور می‌توانیم صفرش کنیم. من این کار را نکردم چون به نظرم سر موقع نمایش داده می‌شوند.&lt;/p&gt;
&lt;p&gt;همین‌طور می‌توان با(setq show-paren-style 'MODE) تعیین کرد که نمایش هر جفت پرانتز چطور باشد. که برای این کار باید عبارت MODE را با یکی از سه گزینهٔ زیر جایگزین کنیم:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;parenthesis&lt;/strong&gt; که مد پیش‌فرض است و فقط پرانتز‌های دو طرف را نمایش می‌دهد.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;expression&lt;/strong&gt; که علاوه بر پرانتز‌ها‌، متن درونشان هم برجسته می‌شود.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;mixed&lt;/strong&gt; که اگر پرانتز‌ها بالانس باشند مثل مد parenthesis عمل می‌کند و گرنه مثل expression.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;به همین سادگی می‌توانید آن‌طور که می‌خواهید این رفتار ایمکس را هم کنترل کنید.&lt;/p&gt;
&lt;p&gt;من این آموزش را نمی‌دانم از کجای اینترنت یاد گرفتم. ولی این &lt;a title="Emacsfu" href="http://emacs-fu.blogspot.de/2009/01/balancing-your-parentheses.html" target="_blank"&gt;وبلاگ&lt;/a&gt; هم به آن اشاره کرده که وبلاگ عالی‌ای هم هست. پیشنهاد می‌کنم از دستش ندهید. خیلی خیلی تکنیک‌های جالبی با آن یاد خواهید گرفت.&lt;/p&gt;</description><category>Emacs</category><category>Emacs-fu</category><category>lisp</category><category>Parenthesis</category><category>ایمکس</category><category>برنامه نویسی</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920127yn-ymkhs-dwst-dshtny-blns-khrdn-prn.html</guid><pubDate>Tue, 16 Apr 2013 12:24:21 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (ergoemacs-mode)</title><link>http://shahinism.github.io/posts/blog13920119yn-ymkhs-dwst-dshtny-ergoemacs-mode.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;قبلا هم گفتم‌، ایمکس در حالت عادی‌، قابل قبول است‌، ولی خیلی خیلی می‌تواند بهتر باشد. یکی از اولین عادت‌ها بعد از مهاجرت به ایمکس‌، کلید‌های میانبر پر استفاده‌اش است. در &lt;a title="این ایمکس دوست داشتنی (تعریف کلید میانبر)" href="http://shahinism.com/blog/1392/01/17/%d8%a7%db%8c%d9%86-%d8%a7%db%8c%d9%85%da%a9%d8%b3-%d8%af%d9%88%d8%b3%d8%aa-%d8%af%d8%a7%d8%b4%d8%aa%d9%86%db%8c-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%a9%d9%84%db%8c%d8%af-%d9%85%db%8c%d8%a7%d9%86%d8%a8/"&gt;پست قبلی&lt;/a&gt; در موزد کلید‌های میانبر ایمکس حرف زدیم. اما بدیهی است که تعریف کلید میانبر برای دستوراتی این چنین پر استفاده که هم با دیگر کلید‌های میانبر تعریف شده در محیط‌های مختلف تداخل نداشته باشد و هم یاد آوری‌شان آسان باشد‌، کار آسانی نیست. خصوصا این که ایمکس پیشنهاد می‌کند کلید میانبر‌تان با C-c شروع شود و با یک کاراکتر تکی ادامه یابد. تعارف که نداریم‌، خیلی محدود است. ضمن این که ما کلید‌های آن‌چنان پر استفادهٔ زیادی نداریم که بخواهیم به همچین آکورد‌های سنگینی محدود شویم.
کلید‌های پر استفادهٔ عمومی شامل انتقال نشانگر‌، Yanking، پاک کردن کاراکتر‌ها‌، مدیریت پنجره‌ها و جستجو‌هاست. این‌ها دستوراتی هستند که در اکثر ویرایش‌ها به آن‌ها نیاز داریم. ضمن این که بسیاری از این دستورات در برنامه‌های دیگر هم شامل کلید‌های میانبری هستند که تقریبا به صورت یک استاندارد در آمده‌اند. نمونه‌ای از این دستورات‌، کپی و پیست است. شما در اکثر محیط‌ها‌، از جمله مرورگر‌تان‌، با C-c کپی می‌کنید و با C-v پیست. حالا باید در ایمکس آن را با C-w و C-y جایگزین کنید. خوب یک کمی ترک عادت نیاز دارد‌، ولی تلاش سختی است. البته ایمکس خودش یک CUA-mode دارد که می‌توان به راحتی اضافه کردن(cua-mode 1) در ‎.emacs آن را فعال کنید. ولی در مورد باز کردن یک فایل جدید چطور؟ در اکثر برنامه‌ها این کار با C-o امکان‌پذیر است‌، در حالی که در ایمکس باید این کار را با C-x C-f انجام دهید! سخت است دیگر!&lt;/p&gt;
&lt;p&gt;سخت‌تر از همه این که به QWERTY وابسته‌اند. آن وقت است که اگر به &lt;a title="چینش (لایوت) Workman و داستان مهاجرتم" href="http://shahinism.com/blog/1392/01/14/%da%86%db%8c%d9%86%d8%b4-%d9%84%d8%a7%db%8c%d9%88%d8%aa-workman-%d9%88-%d8%af%d8%a7%d8%b3%d8%aa%d8%a7%d9%86-%d9%85%d9%87%d8%a7%d8%ac%d8%b1%d8%aa%d9%85/"&gt;Workman&lt;/a&gt; یا Colemak سوئیچ کنید‌، انگار به کیبورد‌تان دینامیت بسته‌اید! از آن بد‌تر این که با کاراکتر‌های فارسی کار نمی‌کنند.&lt;/p&gt;
&lt;p&gt;این مقدمه را گفتم که بگویم‌، عده‌ای جمع شده‌اند و مدی ساخته‌اند به اسم &lt;a title="Ergoemacs official page" href="http://ergoemacs.org/index.html" target="_blank"&gt;ergoemacs-mode&lt;/a&gt; که هدفش حل مشکلات ذکر شده در مقدمهٔ بالاست. نتیجه‌، از عکس زیر معلوم است:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="ergoemacs-mode رو چینش workman" src="http://dl.dropbox.com/u/25017694/Blog-photos/ergoworkman.png" width="586" height="218"&gt; ergoemacs-mode رو چینش workman&lt;/p&gt;
&lt;p&gt;این عکس طبق چینش Workman تولید شده‌،‌ ولی جای دکمه‌ها در لایوت‌های دیگر‌، از جمله QWERTY و Colemak هم یک‌سان است. از نکات مهم مد نظر قرار داده شده در هنگام طراحی این Key binding‌ها می‌توان به موارد زیر اشاره کرد:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;  کلید‌های Home row بهترین‌ها هستند.&lt;/li&gt;
    &lt;li&gt;Alt خیلی بهتر از Ctrl است. Alt را باید با شصت گرفت که زورش خیلی بیشتر از انگشت کوچیکهٔ مخصوص Ctrl است!&lt;/li&gt;
    &lt;li&gt;به جای سرحرف اول دستورات‌، بهتر است به مکان دستورات هم خوانواده توجه شود. مثلا به مکان کلید‌های جاب‌جایی نگاه کنید. همین‌طور کلید‌های پاک کردن را ببینید!&lt;/li&gt;
    &lt;li&gt;و چند‌تای دیگر که آن‌قدرها هم مهم نیستند.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;نکته این‌جاست که نتیجهٔ کار خیلی عالی شده. آن‌قدر عالی که طی رد و بدل چند ایمیل‌ در&lt;a title="ergoemacs mailing list" href="https://groups.google.com/group/ergoemacs" target="_blank"&gt; لیست ایمیل&lt;/a&gt; پروژه‌، زبان فارسی را هم به این مجموعهٔ کامل اضافه کردیم که نتیجه‌اش را در زیر می‌بینید:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="ergoemacs-mode روی چینتش استاندارد فارسی" src="http://dl.dropbox.com/u/25017694/Blog-photos/ergofa.png" width="586" height="218"&gt; ergoemacs-mode روی چینتش استاندارد فارسی&lt;/p&gt;
&lt;p&gt;کیبورد استاندارد فارسی است که به صورت پیش‌فرض در لینوکس وجود دارد‌، ولی ویندوزی‌ها باید برنامهٔ متناسبش را پیدا و نصب کنند تا پشتیبانی شود D:&lt;/p&gt;
&lt;h5&gt;نصب&lt;/h5&gt;

&lt;p&gt;طبق&lt;a title="این ایمکس دوست داشتنی (مدیر بسته)" href="http://shahinism.com/blog/1392/01/08/%d8%a7%db%8c%d9%86-%d8%a7%db%8c%d9%85%da%a9%d8%b3-%d8%af%d9%88%d8%b3%d8%aa-%d8%af%d8%a7%d8%b4%d8%aa%d9%86%db%8c-%d9%85%d8%af%db%8c%d8%b1-%d8%a8%d8%b3%d8%aa%d9%87/" target="_blank"&gt; آن‌چه که در گذشته گفتم‌&lt;/a&gt;، ergoemacs-mode را از مدیر‌بسته‌های ایمکس نصب کنید و سپس تنظیمات زیر را به فایل ‎.emacs‌‌تان اضافه کنید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;setenv&lt;/span&gt; &lt;span class="s"&gt;"ERGOEMACS_KEYBOARD_LAYOUT"&lt;/span&gt; &lt;span class="s"&gt;"workman"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'ergoemacs-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ergoemacs-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در خط اول‌، اسم لایوت پیش‌فرض را اضافه می‌کنیم‌، و در خط‌های بعد ergoemacs-mode را فراخوانی و فعال می‌کنیم. بعد از یک Restart‌، با کلید‌های جدید روبرو می‌شوید D:&lt;/p&gt;
&lt;h5&gt;گرفتن کمک&lt;/h5&gt;

&lt;p&gt;خوب یک تغییر عادت است و احتمالا اول کار خیلی پیش می‌آید که دستورات قبلی‌تان را بزنید و نتیجه نگیرید! برای پیدا کردن کلید‌های جدید‌، کافیست C-h o را وارد کرده و سپس کلید قبلی‌تان را وارد کنید. این تابع بعد از بررسی کلید‌های قدیمی‌، هم‌تایان جدید‌شان را معرفی می‌کند.&lt;/p&gt;
&lt;h5&gt;دیگر سطوح&lt;/h5&gt;

&lt;p&gt;یکی از ویژگی‌های ergoemacs-mode‌، قابلیت تعیین سطحش است. سطوح مختلفی که با توجه به سلیقه‌های مختلف کاربران طراحی شده است. مثلا سطح guru کلید‌های فلش را برای تغییر موقعیت نشانگر می‌بندد و بعد از هر بار زدنشان‌، کلید‌های متناسب با سلیقهٔ ایمکس را نشان‌تان می‌دهد. و یا سطح master (فکر کنم) کلید backspace را خاموش می‌کند تا مجبور شوید از روش‌های پاک کردن کاراکتر ایمکس بهره بگیرید که سریع‌تر است. برای تنظیم این ویژگی‌ها کافیست سطح مورد نظر را انتخاب کنید (بعد از نصب ergoemacs از منو انتخابش کنید و ergoemacs variants را ببینید) و در دستور(setq ergoemacs-variant "SATH") آن را در جای SATH قرار دهید.&lt;/p&gt;
&lt;h5&gt;ergoemacs-extras&lt;/h5&gt;

&lt;p&gt;با فراخوانی این تابع در ایمکس‌، ergoemacs اقدام به ایجاد فایل‌های راهنمای کیبورد ergo در سطوح مختلف به فرمت svg می‌کند که می‌تواند خیلی کمک کننده باشد (عکس‌های موجود در این نوشته هم با همین روش ایجاد شده‌اند.). همین‌طور فایل‌هایی برای تطابق این کلید‌ها با محیط‌های دیگر از جمله bash ایجاد می‌شود که می‌توانند در ایجاد یک‌پارچگی برای محیط کار عالی باشند. (هنوز امتحانش نکرده‌ام ولی نتیجه‌اش را به زودی اطلاع می‌دهم.)&lt;/p&gt;
&lt;p&gt;این فایل‌ها در مسیر ‎~‎‍/.emacs/ergoemacs-extras در دسترسند که با توجه به سطوح مختلف پوشه‌بندی شده‌اند.&lt;/p&gt;
&lt;h5&gt;نتیجه&lt;/h5&gt;

&lt;p&gt;به نظر من نتیجهٔ کار فوق‌العاده قابل قبول است. راحتی استفاده از کلید‌های پر کاربرد و راحت‌تر از آن معکوس کردن اکثر دستورات با Shift فوق‌العاده کمک می‌کند. به طور پیش‌فرض برای خیلی کار‌ها مجبوریم در ایمکس از ارسال آرگومان به دستورات برای تغییر حالت‌شان استفاده کنیم که در Ergoemacs این کار عموما با Shift انجام می‌گیرد. مثلا C-f جستجوی رو به جلو انجام می‌دهد و C-S-f جستجوی رو به عقب!&lt;/p&gt;
&lt;p&gt;از طرفی کلید‌های C-a که در تمام محیط‌های دیگر برای انتخاب کل محتویات صفحه است و یا کلید‌های C-z, C-x, C-c, C-v, C-f, C-o, C-s, C-s-s , و خیلی کلید‌های دیگر که در محیط‌های دیگر از آن‌ها بهره می‌گیریم‌، به راحتی در این‌جا نیز جواب می‌دهند و کار ویرایش را فوق‌العاده راحت‌تر کرده‌اند. حتی با Ergoemacs دستور جدیدی اضافه شده که می‌توان با C-n یک صفحهٔ جدید ساخت‌، بدون این که نیاز به افزودن نامی به آن داشته باشیم.&lt;/p&gt;
&lt;p&gt;یک قابلیت جالب دیگر‌، استفاده از کلید‌های yanking‌ (کپی پیست در ایمکس) بدون Region (متن انتخاب شده) است. در این صورت‌، دستورات کل خط یا صفحه را تحت تاثیر قرار می‌دهند.&lt;/p&gt;
&lt;p&gt;در آینده بیشتر هم در مورد ergoemacs حرف می‌زنیم.&lt;/p&gt;</description><category>CUA-mode</category><category>Emacs</category><category>ergoemacs-mode</category><category>ایمکس</category><category>برنامه نویسی</category><category>دوره</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920119yn-ymkhs-dwst-dshtny-ergoemacs-mode.html</guid><pubDate>Mon, 08 Apr 2013 19:29:09 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (تعریف کلید میانبر)</title><link>http://shahinism.github.io/posts/blog13920117yn-ymkhs-dwst-dshtny-tryf-khlyd-mynb.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از حیاتی‌ترین چیز‌هایی که در ایمکس لازم است بدانیم‌، چگونگی تعریف کلید میانبر برای توابع مختلف است. همان‌طور که احتمالا تا این‌جای قضیه متوجه شده‌اید‌، همهٔ کار‌هایی که در ایمکس انجام می‌دهیم‌، توابعی است که چه همراه خود ایمکس وجود دارند و چه با استفاده از بسته‌هایی که نصب می‌کنیم به آن اضافه می‌شوند. این توابع را می‌توان به صورت M-x FUNCTION_NAME RET  صدا کرد. اما در هنگام کار در ایمکس‌، سخت است که برای هر دستوری‌، مثل رفتن به خط بعد/قبل بیاییم و به این روش عمل کنیم. این است که برای هر تابع پر استفاده‌ای که داریم‌، یک کلید میانبر تعریف می‌کنیم.
لازم به ذکر است که برای اثبات بحث بالا‌، می‌توانید از تابع describe-key  همراه ایمکس استفاده کنید. کار این تابع این است که به شما بگوید که کلید میانبر مد نظر‌تان‌، چه تابعی را صدا می‌کند. برای نمونه‌، این دستور را وارد کنید M-x describe-key RET C-x C-f . همان‌طور که می‌بینید تابع مربوطه در یک پنجرهٔ جدید به نمایش در می‌آید. حالا برویم سر بحث تعریف کلید میانبر:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h5&gt;کلید میانبر سراسری&lt;/h5&gt;
&lt;p&gt;منظور از کلید میانبر سراسری‌، کلید‌هایی است که در همهٔ Major-mode‌ها (مد‌های اصلی) به راحتی عمل می‌کنند. برای نمونه C-n  یک کلید میانبر سراسری است. در تمامی مد‌ها اعم از ویرایش متن معمولی و یا کد برنامهٔ C‌، این کلید میانبر‌، نشانگر را به خط بعد منتقل می‌کند. برای تعریف چنین کلید میانبری می‌توانیم از یکی از دو روش زیر بهره ببریم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"KEY"&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;define-key&lt;/span&gt; &lt;span class="nv"&gt;global-map&lt;/span&gt; &lt;span class="s"&gt;"KEY"&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;برای کسب اطلاعات بیشتر در مورد هر کدام از این توابع می‌توانید از تابع describe-function  همراه ایمکس کمک بگیرید. برای مثال M-x describe-function RET global-set-key RET . یا از کلید میانبرش استفاده کنید C-h f . همین‌طور اگر نشان‌گرتان روی یک تابع ایمکس باشد‌، خود تابع می‌تواند آن را حدس بزند.&lt;/p&gt;
&lt;p&gt;تابع اول که تقریبا سر راست است. global-set-key  همان‌طور که از نامش پیداست‌، یک کلید سراسری به اسم KEY که می‌تواند ترکیبی به صورت&lt;span class="lang:default decode:true  crayon-inline"&gt;"‎\C-c f" باشد‌، برای تابع FUNCTION_NAME تعریف می‌کند. همان‌طور که احتمالا متوجه شده‌اید‌، من برای نشان‌دادن Ctrl  در کلید میانبرم از ‎‎\C  استفاده کردم. همین‌طور برای Alt  باید از ‎\M  استفاده کنم. تعریف کلید به این صورت شاید کمی خسته کننده و نا خوانا به نظر بیاید. برای راحتی بیشتر می‌توان از تابع kbd  استفاده کرد. برای نمونه طبق مثالمان‌، همچین چیزی خواهیم داشت:&lt;/span&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kbd&lt;/span&gt; &lt;span class="s"&gt;"C-c f"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خود تابع kbd  می‌داند که چطور این کلید را ترجمه کند. برای کسب اطلاعات بیشتر در این مورد می‌توانید باز هم از C-h f  یا تابع متناظرش استفاده کنید. باور کنید که اطلاعات خیلی بهتری به دست می‌آورید ;-)&lt;/p&gt;
&lt;p&gt;در تابع دوم ما کار مشابهی را انجام دادیم‌، با این تفاوت که تابع define-key  نیاز به این دارد که بداند کلید میانبر را در کدام محیط اجرا کند. به عبارت دیگر‌، کلید میانبر در کدام Mode در دسترس باشد. از آن‌جایی که قصد ما تعریف کلید میانبر سراسری است به محیط global-map  اشاره می‌کنیم که به define-key  می‌فهماند کلید باید در همه جا در دسترس باشد.&lt;/p&gt;
&lt;h5&gt;کلید میابر محدود به مد خاص&lt;/h5&gt;

&lt;p&gt;با این توضیح آخر بخش قبل‌، فکر کنم موضوع کاملا روشن شده باشد. کافیست برای تعریف میانبر برای یک مد خاص‌، محیط مربوط به آن مد را به define-key  نشان دهیم. برای مثال اگر می‌خواهیم که کلید میانبر تنها در محیط متنی در دسترس باشد‌، به جای global-map  از text-mode-map  استفاده می‌کنیم. محیط‌های مربوط به هر مد اصلی‌، عموما به صورت mode-name-map  شناسایی می‌شوند و در هنگام تعریف کلید‌، کافیست نام map مد مورد نظر‌تان را کشف کنید ;-)&lt;/p&gt;</description><category>define-key</category><category>Emacs</category><category>global-map</category><category>global-set-key</category><category>text-mode-map</category><category>ایمکس</category><category>برنامه نویسی</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920117yn-ymkhs-dwst-dshtny-tryf-khlyd-mynb.html</guid><pubDate>Sat, 06 Apr 2013 09:06:38 GMT</pubDate></item><item><title>چینش (لایوت) Workman و داستان مهاجرتم</title><link>http://shahinism.github.io/posts/blog13920114chynsh-lywt-workman-w-dstn-mhjrtm.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;اصلا مهم نیست که از چه کامپیوتری استفاده می‌کنید‌، Mac, Linux‌، Windows, ارزان‌قیمت‌، گران‌قیمت‌، کوچک‌‌ یا بزرگ. همچنین اصلا مهم نیست که برای چه کاری پشت کامپیوتر می‌نشینید‌، برنامه‌نویسی‌، تحقیقاتی‌، نوشتن‌، بازی‌، وب‌گردی و …! در همهٔ این حالات‌، اصلی‌ترین رابط شما و کامپیوتر‌، کیبورد زیر دست‌تان است. کیبوردی که در تمام این حالات‌، هم‌شکل است. شکلی که صد و اندی سال پیش طراحی شده و هدف از طراحی‌اش بسیار بسیار متفاوت با استفاده‌هایی است که امروز‌ها از آن می‌شود.
طراحی چینش صفحه کلید QWERTY زیر دست‌تان‌، به دوران ماشین‌های تایپ بر می‌گردد. ماشین‌هایی مکانیکی که بعد از فشردن هر دکمه روی‌شان‌، پایهٔ متصل به حرف تایپ شده‌، به روی صفحهٔ کاغذ می‌خورد و حرف مورد نظر چاپ می‌شد. اما مشکل این‌جا بود که حروفی وجود داشتند که نسبت به بقیه‌، استفادهٔ بیشتری در کلمات داشتند و این یعنی کلمات بیشتری بودند که با ترکیب آن‌ها ساخته می‌شدند. با این وصف‌، نزدیکی مکانیکی حروف پر استفاده‌، در آن ابعاد کوچک و در سرعت‌های بالا‌، مشکل آفرین بود! پایه‌ها به هم گیر می‌کردند.&lt;/p&gt;
&lt;p&gt;این شد که در طراحی QWERTY سعی شد که پایه‌های حروف پر استفاده دور‌تر از هم قرار گیرند و در نتیجه‌، کلید‌های مربوطه‌شان به دلیل محدودیت سخت‌افزاری باید دور‌تر از هم قرار می‌گرفت. در نتیجه چینشی به وجود آمد که بیش از صد سال مورد استفاده قرار گرفت و تقریبا به یک استاندارد تبدیل شد. استانداردی که هیچ توجهی به نیاز‌های جدید کاربرانش نمی‌کند.&lt;/p&gt;
&lt;p&gt;در قرن ۲۱‌، دیگر این چینش در ابزاری محدود به سخت‌افزار مورد استفاده قرار نمی‌گیرد. در عوض حالا می‌توان چینشی طراحی کرد که بیشتر به نیاز کاربر بیاید. چینشی که در آن کاربر مجبور به جابجایی زیاد انگشتانش نباشد. این جابجایی‌ها شاید به نظر کوچک بیایند‌، ولی در تایپ‌های طولانی مدت شما با همین قدم‌های کوچک‌، کیلو‌متر‌ها مسافت را طی کرده‌اید! باور نمی‌کنید؟ کافیست فاصلهٔ بین هر دو دکمهٔ کنار هم کیبورد را چیزی در حدود ۲ سانتی‌متر فرض کنیم. آن وقت برای تایپ همین پاراگراف حاضر‌، تا الان من حداقل ۹۵۰ سانتی‌متر (۴۷۵ کاراکتر) و آن هم تنها در صورتی که تمام کاراکتر‌هایم در کنار هم باشند (در کنار هشت انگشت تایپم) مصافت طی کرده‌ام! (این حداقل خیلی خیلی ایده‌آل است و فکر نمی‌کنم هرگز اتفاق بیافتد، حداقل در چینش فارسی‌! ولی فکر کنم مثال مناسبی برای نشان دادن عمق موضوع است.)&lt;/p&gt;
&lt;p&gt;از قرار این موضوع تا 1930 و انتشار چینش Dvorak چندان جدی گرفته نشد. چینشی که تنها سعی می‌کرد‌، قابل قبول‌تر از QWERTY باشد. تغییراتش نسبت به آن زیاد نبودند‌، ولی نتیجهٔ کاربر پسند‌تری داشتند. اما به نظرم‌، پرجرات‌ترین تغییر در این چینش سنتی‌، توسط &lt;a title="Colemak official" href="http://colemak.com" target="_blank"&gt;Colemak&lt;/a&gt; ایجاد شد! 2006! ۷۶ سال طول کشید تا این نیاز عمیقا درک شود! البته بودند چینش‌هایی که سعی در بهبود QWERTY داشته باشند‌، اما Colemak متفاوت بود. چینشی که در آن سعی شد‌، پر استفاده‌ترین کاراکتر‌ها‌، در ردیف وسطی قرار گیرند (ردیفی که در روش تایپ استاندارد‌، انگشتان باید روی آن‌ها قرار گیرند و در اصطلاح به آن‌ها Home row می‌گویند). نتیجهٔ کار فوق‌العاده بهتر شده بود. جادی عزیز‌، خیلی وقت پیش در مورد Colemak و بهبود‌هایش نسبت به &lt;a title="کولمک در وبلاگ جادی" href="http://jadi.net/2009/02/%d8%b5%d9%81%d8%ad%d9%87-%da%a9%d9%84%db%8c%d8%af-%da%a9%d9%88%d9%84%d9%85%d8%a7%da%a9/" target="_blank"&gt;QWERTY نوشت&lt;/a&gt; که پیشنهاد می‌کنم بخوانید.&lt;/p&gt;
&lt;p&gt;و اما &lt;a title="Workman official" href="http://www.workmanlayout.com/blog/" target="_blank"&gt;Workman&lt;/a&gt;! در حقیقت چینش مورد بحث ما‌، سعی کرده نسخهٔ بهبود یافتهٔ Colemak باشد. خیلی از ایده‌ها را از آن به ارث برده و شباهت خیلی خیلی کمتری نسبت به QWERTY دارد. طراح Workman‌، این‌طور فکر می‌کرد که همیشه استفاده از Home row بهترین جا برای قرار گرفتن حروف نیست. مثلا نکته این‌جا بود که حرکت طبیعی انگشتان‌، کلید I در صفحه‌کلید QWERTY را‌، راحت‌تر از H تایپ می‌کنند (انگشتان به بالا یا پایین‌، راحت‌تر حرکت می‌کنند تا به چپ و راست!). این بود که نقشه‌ای به صورت زیر طراحی کرد که میزان راحتی دسترسی نسبت به کلید‌ها را در آن نمره دهی کرده بود:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="امتیاز‌دهی به کلید‌های کیبورد بر اساس میزان راحتی در دسترسی" src="http://dl.dropbox.com/u/25017694/Blog-photos/keyboard_graded1.png" width="499" height="166"&gt; امتیاز‌دهی به کلید‌های کیبورد بر اساس میزان راحتی در دسترسی&lt;/p&gt;
&lt;p&gt;پس ار آن تنها کافی بود که کاراکتر‌ها را نسبت به میزان استفاده‌اش در این خانه‌ها جا دهد. نتیجهٔ کار و امتیاز‌های کسب شده در مقایسه با دیگر چینش‌ها چشم‌گیر بود! مثلا در این‌جا میزان استفاده از دو ستون وسط در چند لایوت مختلف را می‌بینیم (ستون‌هایی که نیاز به حرکت انگشتان به چپ و راست دارند که باعث کشش عضلانی انگشتان می‌شود):&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul style="direction: rtl; text-align: left; list-style: none outside none;"&gt;&lt;li&gt;QWERTY: 22%&lt;/li&gt;
    &lt;li&gt;Dvorak: 14%&lt;/li&gt;
    &lt;li&gt;Colemak: 12%&lt;/li&gt;
    &lt;li&gt;Workman: 6%&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;یا مثالی نزدیک‌تر به نیاز‌مان. میزان جابجایی انگشت‌ها:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="نتیجهٔ تست تایپ در چهار چینش مختلف" src="http://dl.dropbox.com/u/25017694/Blog-photos/don-quixote.png" width="559" height="404"&gt; نتیجهٔ تست تایپ در چهار چینش مختلف&lt;/p&gt;
&lt;p&gt;در این مثال تایپ کتاب &lt;a title="Don Quixote on wikipedia" href="http://en.wikipedia.org/wiki/Don_Quixote" target="_blank"&gt;Don Quixote&lt;/a&gt; با لایوت‌های مختلف شبیه سازی شده. همان‌طور که می‌بینید Colemak مصافت کمتری نسبت به QWERTY و Dvorak را طی کرده. اما Workman از آن‌ هم کمتر است. ۶۹۶ متر! شاید فکر کنید که این خیلی کم به نظر می‌آید. ولی بیایید به روش قبلی‌مان حسابش کنیم. ۶۹۶ متر = ۶۹۶۰۰ سانتی‌متر = ۳۴۰۰۰ دکمه (با احتساب فاصلهٔ تقریبا ۲ سانتی‌متری بین هر دو دکمهٔ کنار هم). یعنی با Workman سی و چهار هزار دکمهٔ کمتر فشار داده شده.&lt;/p&gt;
&lt;p&gt;البته بهبود این چینش به Workman ختم نمی‌شود. چینش‌های دیگری هم هستند که خرده‌هایی به این لایوت گرفته‌اند و سعی می‌کنند به روش خود آن را بهبود ببخشند. خوبی این همه چینش جدید این است که می‌توان با دست باز‌تری انتخاب کرد و نتیجهٔ مطلوب‌تری گرفت. همین‌جا هم بگویم که اصلا تایید نمی‌کنم که Workman بهترین چینش ممکن است‌! این چینش اولین و آخرین چینش انتخابی من برای مهاجرت است!&lt;/p&gt;
&lt;h5&gt;قضیهٔ مهاجرت من به Workman&lt;/h5&gt;

&lt;p&gt;دو سال و خرده‌ای پیش بود که بعد از هشت نه سال کاربر کامپیوتر بودن‌، تصمیم گرفتم که تایپ استاندارد را یاد بگیرم و هی در هنگام تایپ به دستانم نگاه نکنم (می‌دانم خیلی دیر بود). حقیقتش برایم خیلی سخت بود. حتی چند باری قبلا تلاش کرده بودم و دلزده رهایش کرده بودم. مشکل این‌جا بود که بیش از حد سعی می‌کردم به حافظه تکیه کنم. این بود که بعد از یک استراحت چند هفته‌ای‌، دوباره شروع می‌کردم و نتیجهٔ بهتری می‌گرفتم. تا این که خلاصه به سرعت تایپ معقولی رسیدم.&lt;/p&gt;
&lt;p&gt;سوئیچ به فارسی فوق‌العاده آسان‌تر بود. تنها کافی بود که یاد بگیرم جای کدام حرف انگلیسی‌، چه تایپ کنم. بعد از معرفی Colemak توسط جادی هم سعی کردم که آن را بچشم‌، ولی به دلم ننشست. شاید به خاطر این که آن موقع با QWERTY هم آشنا نبودم. ولی نه‌، من Workman را هم تنها به خاطر تنوعش انتخاب کردم!&lt;/p&gt;
&lt;p&gt;این یعنی این که اصلا فکر نکنید که این اطلاعاتی که در بالا نوشتم‌‌، دلیل مهاجرتم به Workman بوده باشد. این چینش هر چقدر هم خوب باشد‌، بسیاری از برنامه‌های وابسته به کیبوردم را مثل &lt;a title="تجربهٔ کار با i3 یک رقیب قدر‌!" href="http://shahinism.com/blog/1391/04/15/%d8%aa%d8%ac%d8%b1%d8%a8%d9%87%d9%94-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-i3-%db%8c%da%a9-%d8%b1%d8%ba%db%8c%d8%a8-%d9%82%d8%af%d8%b1%e2%80%8c/" target="_blank"&gt;i3&lt;/a&gt;, &lt;a title="کنترل کامل فایرفاکس با کیبورد (Pentadactyl, Vimperator, Firemacs)" href="http://shahinism.com/blog/1391/01/05/%da%a9%d9%86%d8%aa%d8%b1%d9%84-%da%a9%d8%a7%d9%85%d9%84-%d9%81%d8%a7%db%8c%d8%b1%d9%81%d8%a7%da%a9%d8%b3-%d8%a8%d8%a7-%da%a9%db%8c%d8%a8%d9%88%d8%b1%d8%af-pentadactyl-vimperator-firemacs/" target="_blank"&gt;pentadactyl&lt;/a&gt; و از همه مهم‌تر &lt;a title="چگونه ایمکس‌مان را تربیت کنیم (قسمت اول)" href="http://shahinism.com/blog/1391/04/23/%da%86%da%af%d9%88%d9%86%d9%87-%d8%a7%db%8c%d9%85%da%a9%d8%b3%e2%80%8c%d9%85%d8%a7%d9%86-%d8%b1%d8%a7-%d8%aa%d8%b1%d8%a8%db%8c%d8%aa-%da%a9%d9%86%db%8c%d9%85-%d9%82%d8%b3%d9%85%d8%aa-%d8%a7%d9%88/" target="_blank"&gt;Emacs&lt;/a&gt; را تحت تاثیر قرار می‌دهد! تغییر کلید‌های یک مرحله‌ای را می‌شود تحمل کرد‌، ولی با تغییر به Workman یک دستور سادهٔ ایمکس مثل C-x C-f به کابوس تبدیل می‌شود! (به زودی این مشکل را هم در ایمکس حل خواهیم کرد!)&lt;/p&gt;
&lt;p&gt;ولی حدودا بیست روز پیش و فقط و فقط‌، برای ایجاد تنوع تصمیم به تغییر چینش کیبورد گرفتم. بعد از یک جستجوی چند ساعته هم تصمیم نهایی‌ام شد Workman. قبل از آن هم یک تست از سرعت تایپ QWERTYام گرفتم محض یادگاری که نتیجه‌اش شد ۲۰۴ کاراکتر در دقیقه و با درستی ۹۹.۳ درصد! و انتقال شروع شد!&lt;/p&gt;
&lt;p&gt;یک کابوس به تمام معنا! مشکل را تازه درک کرده بودم. در هنگام تایپ اصلا به حافظه به آن معنی که می‌شناختم نیازی نبود. نیاز اصلی حافظهٔ عضلانی است. و QWERTY خیلی محکم در این حافظه ثبت شده بود. تا موقعی که شش دانگ حواسم جمع تایپ کردن بود مشکلی نبود. ولی تا بیخیال حافظه‌ام می‌شدم‌، انگشتانم به QWERTY سوئیچ می‌کردند. جدال با این حافظه سخت بود. شاید بخندید‌، ولی دو سه روز اول‌، سردرد شدیدی گرفتم! از آن مهم‌تر این که به صورت ناخودآگاه نکته بین‌تر شده بودم. این است که نتیجه گرفتم تغییر عادات‌، خیلی خیلی به درد بخور است!&lt;/p&gt;
&lt;p&gt;خلاصهٔ کلام‌، بعد از ۲۰ روز‌، الان دیگر نمی‌توانم به QWERTY تایپ کنم! کاملا پاک شده. ولی چه باک‌، هر وقت به Workman دسترسی نداشتم‌، به دستانم نگاه می‌کنم و تایپ می‌کنم D:. جالبی‌اش این‌جاست که خطای تایپ فارسی‌ام هم زیاد شده بود. یادتان هست که گفته بودم که برای تایپ فارسی کاراکتر‌ها را با همتایان انگلیسی‌شان لینک کرده بودم؟ فکر کنم مشکل از همان‌جا آب می‌خورد.&lt;/p&gt;
&lt;p&gt;ولی الان نتیجه به نظرم قابل قبول شده! سرعت تایپم به ۲۲۶ کاراکتر در دقیقه رسیده! این در حالی است که درستی کاراکتر‌ها به ۹۴ درصد نزول پیدا کرده. یک حساب سرسری یعنی این که اگر میزان درستی کاراکتر‌ها بهبود ببخشم‌، نتیجهٔ سرعت تایپ از این هم بیشتر خواهد بود که به نظرم خیلی جذاب است.&lt;/p&gt;</description><category>Colemak</category><category>Dvorak</category><category>Layout</category><category>QWERTY</category><category>Workman</category><category>ایمکس</category><category>بررسی</category><category>برنامه نویسی</category><category>نرم افزار</category><guid>http://shahinism.github.io/posts/blog13920114chynsh-lywt-workman-w-dstn-mhjrtm.html</guid><pubDate>Wed, 03 Apr 2013 11:58:57 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (مقدمه)</title><link>http://shahinism.github.io/posts/blog13920107yn-ymkhs-dwst-dshtny-mqdmh.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;ایمکس‌، ایمکس‌، ایمکس‌! اگر از دوست‌داران نهضت نرم‌افزار آزاد و شاید نهایتا متن‌باز باشید‌، احتمالا اسمش را شنیده‌اید (این در صورتی است که در حال حاضر از آن استفاده نمی‌کنید D:). خوب اگر شرط ذکر شده شامل حالتان نمی‌شود‌، تنها می‌توانم بگویم که شما هیچ تصوری نسبت به این که ایمکس‌، چه نوع نرم‌افزاری است‌، نمی‌توانید داشته باشید‌! نه‌، خوب به بند آخر جمله توجه کنید‌: &lt;strong&gt;&lt;span style="color: #ff0000;"&gt;نمـــی‌توانــــید‌، داشته باشید&lt;/span&gt;&lt;/strong&gt;! اگر اسم ایمکس به گوش‌تان خورده و هنوز پارهٔ تنتان نشده‌، احتمالا تنها با عبارت‌هایی مثل:«من از &lt;strong&gt;vim&lt;/strong&gt; استفاده می‌کنم.» یا مثلا «‌من با &lt;strong&gt;IDE‌ها&lt;/strong&gt; راحت‌تر برنامه توسعه می‌دم.» یا اصلا از این‌ها بدتر‌: «من اصلا برنامه‌نویس نیستم که بخوام بدونم ایمکس چیه» خودتان را گول زده‌اید!
گفتم «شما در صورتی که از ایمکس استفاده نمی‌کنید، نمی‌توانید تصوری از چیستی‌اش داشته باشید» چون عملا با هیچ نمونهٔ مشابهی از آن کار نکرده‌اید‌! شما حتی نمی‌دانید که این نرم‌افزار قادر است کدام نیاز‌تان را بر طرف کند. با خود‌تان رو راست باشید‌‌! قبول کنید که با ابزاری روبرو هستید که نمی‌دانید باید چه انتظاری از آن داشته باشید.&lt;/p&gt;
&lt;p&gt;&lt;a title="ایمکس در ویکی‌پدیا" href="http://wikipedia.org/wiki/Emacs" target="_blank"&gt;&lt;img alt="لوگوی Gnu Emacs." src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Emacs-logo.svg/270px-Emacs-logo.svg.png" width="270" height="217"&gt;&lt;/a&gt; لوگوی Gnu Emacs.&lt;/p&gt;
&lt;p&gt;خوب احتمالا به قدر کافی گیج شده‌اید‌! حتما با خود می‌گویید که چه نیازی به ابزاری دارم که نمی‌دانم به چه دردی می‌خورد‌؟ خوب کلید مساله همین‌جاست‌! اگر می‌خواهید با ایمکس آشنا شوید‌، باید از او انتظار داشته باشید که تمام کار‌های‌تان را برای‌تان انجام دهد‌! چطور؟ خوب چطوری‌اش را خیلی ساده واگذار می‌کنیم به پست‌هایی که قرار است طی یک سری پست سریالی در این وبلاگ منتشر کنم! اما قبل از شروع به انتشار‌شان باید به چند نکته اشاره کنم:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a title="صفحهٔ خانگی ایمکس" href="http://www.gnu.org/software/emacs/emacs.html" target="_blank"&gt;Gnu Emacs&lt;/a&gt;! آن بیرون چند توزیع مختلف ایمکس وجود دارد. ما در این‌جا موضوع بحث‌مان فرزند خلف ریچارد استالمن Gnu Emacs است که قابلیت نصب روی پلتفرم‌های مختلف‌، از جمله ویندوز را دارد. پس نیاز نیست که بترسید. البته مطمئنم اگر هنوز جرات نکرده‌اید از دمپایی ابری مایکروسافت جدا شوید‌، جرات سوئیچ به هیولایی مثل ایمکس را هم نخواهید داشت. هر چند که ایمکس در ویندوز هم می‌تواند زندگی‌تان را عوض کند. ;-)&lt;/li&gt;
    &lt;li&gt;من هم ایمکس نمی‌دانم‌! ساده است. حدودا یک سالی می‌شود که از ایمکس استفاده می‌کنم‌، ولی حتی تا همین یکی دو هفته پیش همیشه با ترسی قلمبه به سراغش می‌رفتم. اما یک جور‌هایی الان احساس می‌کنم به جایی رسیده‌ام که می‌توانم بهتر از ایمکس کار بکشم.&lt;/li&gt;
    &lt;li&gt;قرار نیست در این‌جا ایمکس یادتان بدهم‌! این یکی حتی از قبلی ساده‌تر است. برای یادگیری ایمکس‌، هیچ منبعی بهتر از خود ایمکس نیست! چطور؟ خیلی ساده‌، ایمکس‌تان را باز کنید و &lt;strong&gt;C-h t&lt;/strong&gt; را وارد کنید. اگر خیلی خیلی تازه‌کارید این دستوری که نوشتم یعنی‌، کلید Ctrl را پایین نگه دارید‌، h را نوازش کنید و سپس هر دو کلید را رها کرده و t را یک بار فشار دهید. ساده بود؟ آماده باشید که با یکی از هیجان‌انگیز‌ترین آموزش‌های عمرتان روبرو شوید (دروغ گفتم‌، احتمالا خیلی خیلی برای‌تان خسته کننده خواهد بود. چون احتمالا فکر می‌کنید که خیلی از این کار‌ها را با Visual Studio یا چه می‌دانم یک ادیتور دیگر که الان استفاده می‌کنید‌، خیلی راحت‌تر انجام می‌دهید. ولی اگر به من اعتماد دارید‌، باور کنید که اشتباه می‌کنید.).&lt;/li&gt;
    &lt;li&gt;این آموزش که انگلیسی است‌! دقیقا‌! شاید فکر کنید که با ترجمهٔ این آموزش بهتر می‌توانستم کمک کنم. ولی نه‌، آن‌قدر چیز برای یادگرفتن در مورد ایمکس به زبان انگلیسی وجود دارد‌، آن‌قدر نیاز به کمک گرفتن از ایمکس خواهیم داشت‌، آن‌قدر راهنماهای خوب در ایمکس وجود دارد که اگر تا الان انگلیسی‌تان داغان است‌، فکری به حال بهبودش بکنید. نیازی هم به کلاس‌ها و کتاب‌های گران‌قیمت ندارید. همین راهنما را باز کنید و شروع به خواندنش کنید. هر وقت هر جایی گیر کردید‌، با یک دیکشنری ترجمه را پیدا کنید. اوائل کمی سخت است‌، ولی هر چه جلوتر که می‌روید‌، به این شیوهٔ یادگیری بیشتر وابسته می‌شوید و لذت می‌برید ;-)&lt;/li&gt;
    &lt;li&gt;اگر ایمکس یاد نمی‌دهی‌، پس این پست‌هایت به درد چه می‌خورد؟ خوب منظورم از آن بند این بود که چیز‌های پایه‌ای را خودتان باید یاد بگیرید. من در این پست‌ها سعی دارم جاهایی را نشان‌تان دهم که در تخیل‌تان هم نمی‌گنجد.&lt;/li&gt;
    &lt;li&gt;چرا پست‌های سریالی؟ خوب ایمکس خیلی گنده است. خیلی خیلی کار می‌تواند انجام دهد. نوشتن یک کتاب ۱۰۰۰ صفحه‌ای هم نمی‌تواند شما را با همهٔ نادیده‌های‌تان آشنا کند. اما پست‌های کوتاه‌، که هم اشاره به نحوهٔ تنظیم قابلیت‌ها و هم اشاره به ویژگی‌های‌شان دارد‌، می‌تواند هم اشتیاق استفاده از آن‌ها را ایجاد کند و هم وقت کافی برای تجربه‌شان بدهد ;-)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;دیگر ادامه نمی‌دهم‌، همین‌قدر هم برای یک مقدمه کافیست. البته مطمئنم که C-h t برای‌تان مقدمهٔ خیلی خیلی بهتری خواهد بود. پس درنگ نکنید و به سراغش بروید ;-)&lt;/p&gt;</description><category>elisp</category><category>Emacs</category><category>ادیتور</category><category>ایمکس</category><category>ایمکس</category><category>برنامه نویسی</category><category>دوره</category><category>نرم افزار</category><category>ویندوز</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920107yn-ymkhs-dwst-dshtny-mqdmh.html</guid><pubDate>Wed, 27 Mar 2013 09:09:34 GMT</pubDate></item><item><title>دریافت متن ترانه‌های MP3 با لینوکس</title><link>http://shahinism.github.io/posts/blog13911119dryft-mtn-trnhhy-mp3-b-lynwkhs.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;بله‌، بله‌، خودم خوب می‌دانم که هزار و یک برنامهٔ پخش MP3 آن بیرون است که این کار را خودشان مثل آدم انجام می‌دهند. ولی Nokia N70 بنده‌، شعورش به این چیز‌ها قد نمی‌دهد. همین‌قدر هم که می‌تواند فایل صوتی پخش کند‌، جای شکرش باقی است. خوب حقیقتش می‌شود که با خرج کمی GPRS و البته با یک کمی انگولک این متن‌ها را پیدا کرد‌. ولی خوب کالیبر‌، بالا‌تر از این حرف‌هاست. این است که تصمیم گرفتم‌، برای این کار برنامه‌ای سر هم کنم.
&lt;/p&gt;&lt;h5&gt;مقدمات&lt;/h5&gt;
&lt;p&gt;اولین قدم‌، پیدا کردن سایتی بود که هم متن ترانه‌ها را به قدر کفایت داشته باشد‌، هم یک API درست درمان‌، یعنی رابطی که بتوان مثل آدم از طریق برنامه با آن به تبادل داده پرداخت نیز ارائه کند. خوب‌، خوشبختانه‌، این خارجکی‌ها‌، بر خلاف ما‌، سایت بدرد بخور زیاد دارند. پس انتخاب‌هایم خیلی زیاد بودند. اما کمی بیشتر که جستجو کردم دیدم &lt;a title="Fetching lyrics in the command line" href="https://gist.github.com/febuiles/1549991" target="_blank"&gt;آدم سالاری&lt;/a&gt; قبلا همچین اسکریپتی نوشته که مثل چــی هم کار می‌کند ;-)&lt;/p&gt;
&lt;p&gt;اصل اسکریپت همچین جایی است:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;curl -s &lt;span class="s2"&gt;"http://makeitpersonal.co/lyrics?artist=$artist&amp;amp;amp;title=$title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خیلی ساده با curl یک درخواست به API سایت می‌فرستیم که در آن ‎$artist اسم خوانندهٔ ترانه و ‎$title اسم خود ترانه است. که البته‌، چون url‌ها نحو (Syntax) خاص خودشان را دارند‌، این اسکریپت‌نویس دوست داشتنی ما‌، با دو خط زیر‌، اسم خواننده و ترانه را معتبر می‌کند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nv"&gt;artist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;perl -MURI::Escape -e &lt;span class="s1"&gt;'print uri_escape($ARGV[0]);'&lt;/span&gt; &lt;span class="s2"&gt;"$artist_name"&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;

&lt;span class="nv"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;perl -MURI::Escape -e &lt;span class="s1"&gt;'print uri_escape($ARGV[0]);'&lt;/span&gt; &lt;span class="s2"&gt;"$song_title"&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همین‌؟ تمام شد؟‌ خوب این اسکریپت کاری که می‌خواستیم را انجام داد. ولی شاهین را که می‌شناسید‌. دوست دارد کار‌هایش را &lt;a title="چ‌چ‌چ (۹): چطور به صورت فله‌ای لینک‌های یوتیوب را از وب‌سایتی استخراج و دانلود کنیم‌!" href="http://shahinism.com/blog/1390/09/26/%da%86%e2%80%8c%da%86%e2%80%8c%da%86-%db%b9-%da%86%d8%b7%d9%88%d8%b1-%d8%a8%d9%87-%d8%b5%d9%88%d8%b1%d8%aa-%d9%81%d9%84%d9%87%e2%80%8c%d8%a7%db%8c-%d9%84%db%8c%d9%86%da%a9%e2%80%8c%d9%87%d8%a7/" target="_blank"&gt;فله‌ای&lt;/a&gt; انجام دهد! یک کمی سخت است که هر بار بیایم اسم ترانه و خواننده را به اسکریپت بگویم‌، بعد شیلنگ خروجی را بگیرم توی یک فایلی که می‌خواهم و از این حرف‌ها. پس می‌رویم سراغ دستکاری بیشتر این اسکریپت.&lt;/p&gt;
&lt;h5&gt;خجالت بکش شاهین&lt;/h5&gt;

&lt;p&gt;حتما می‌دانید که می‌توان به فایل‌های MP3 تگ زد. همین تگ‌هایی که اسم خواننده و ترانه و ژانر و این‌جور حرف‌ها را می‌توان بهشان خوراند که تا دست آخر با MP3 Player خیلی راحت‌تر بشود سر و سامان‌شان داد. البته اگر راست کار‌تان&lt;a title="موسیقی در وب فارسی‌" href="http://shahinism.com/blog/1389/01/15/%d9%85%d9%88%d8%b3%db%8c%d9%82%db%8c_%d8%af%d8%b1_%d9%88%d8%a8_%d9%81%d8%a7%d8%b1%d8%b3%db%8c%e2%80%8c/" target="_blank"&gt; سایت‌های موسیقی ایرانی&lt;/a&gt; است‌، از این تگ‌ها مطمئنا خیری نسیب‌تان نشده‌، چون از دَم مثل ندید بدید‌ها پرش کرده‌اند با آدرس سایت داغان‌شان ;-)&lt;/p&gt;
&lt;p&gt;به هر حال‌، از آن‌جایی که آلبوم موسیقی مورد نظر من‌، مثل آدم تگ خورده بود‌، قصد داشتم تا از این تگ‌ها استفاده کنم. همیشه هم در مخیله‌ام این‌طور تصور می‌کردم که این تگ‌ها با یک روش مخوفی درون فایل موسیقی که اصلا نمی‌دانم چیست قایم شده‌اند و خواندن‌شان نیاز به کتاب‌خانه‌ای چیزی دارد که من از طرز کارش سر در نمی‌آورم. این بود که قصد داشتم اصلا کل اسکریپت را به برنامه‌ای به پایتون تغییر دهم. ولی خوب‌، یک سرچ کوچک کردم و کلی &lt;b&gt;خجالت کشیدم&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;همان‌طور که در&lt;a title="Bash Script: Reading ID3v1 Tags" href="http://phoxis.org/2011/08/24/bash-script-reading-id3v1-tags/" target="_blank"&gt; این لینک&lt;/a&gt; توضیح داده شده‌، عموما‌، ۱۲۸ بیت آخر فایل MP3 شامل تگ‌های آن است. و ابزار‌های به ظاهر سادهٔ گنو/لینوکسی‌، مثل چـــی‌، کمک‌مان می‌کنند که این تگ‌ها را بخوانیم‌. ببینید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;tail -c128 &lt;span class="s2"&gt;"$file"&lt;/span&gt; | tr &lt;span class="s1"&gt;'\0'&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;id3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;head -c10 &lt;span class="s2"&gt;"$file"&lt;/span&gt; | tr &lt;span class="s1"&gt;'\0'&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;سر هم کردن اسکریپت نهایی&lt;/h5&gt;

&lt;p&gt;دیگر حالا‌، هم همهٔ ابزار‌های مورد نیاز‌مان را داریم‌، هم کلی چیز جدید یاد گرفته‌ایم. این است که‌، اسکریپت نهایی را سر هم می‌کنیم. که می‌توانید از &lt;a title="lyric script" href="https://github.com/shahinism/Scripts/blob/master/Shell/lyric" target="_blank"&gt;این لینک&lt;/a&gt; دریافتش کنید. برای استفاده از آن هم کافیست که اسم هر تعداد ترانهٔ MP3 را که دل‌تان می‌خواهد در جلویش تایپ کنید تا خودش باقی کار‌ها را انجام دهد.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;نکته:&lt;/b&gt; خوب گاها پیش می‌آید که اسم ترانه‌، شامل کلماتی نظیر (Live) و یا (Bonus) باشد. و یا شاید اسم سایتی‌، چیزی را شامل شود. در این صورت‌، احتمالا API ما بر می‌گرداند که چیزی پیدا نکردم و از این حرف‌ها‌. ولی اسکریپت بیشعور ما آن را هم درون یک فایل هم اسم ترانه با فرمت txt ذخیره می‌کند. این‌جایش را دیگر خودتان می‌توانید با هنر دستکاری فایل لینوکسی‌تان‌، راست و ریست کنید ;-)&lt;/p&gt;</description><category>bash</category><category>MP3</category><category>Python</category><category>Script</category><category>برنامه نویسی</category><category>موسیقی</category><category>نرم افزار</category><category>کدباز</category><category>گنو/لینوکس</category><guid>http://shahinism.github.io/posts/blog13911119dryft-mtn-trnhhy-mp3-b-lynwkhs.html</guid><pubDate>Thu, 07 Feb 2013 19:38:27 GMT</pubDate></item><item><title>چطور از وابستگی به گیت‌هاب فرار کنیم: پشتیبان‌گیری از مخازن گیت</title><link>http://shahinism.github.io/posts/blog13911103chtwr-z-wbstgy-bh-gythb-frr-khnym-p.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;گیت این روز‌ها تبدیل به عصای کمکی بزرگی برای انجام پروژه‌هایم شده. خوشبختانه تا دلمان هم بخواهد سرور ارائهٔ خدمات گیت روی اینترنت ریخته که هر کدام مزایا و محدودیت‌های خود‌شان را دارند. من‌باب مالیخولیایی زیادم در پشتیبان‌گیری از پروژه‌ها‌، مطلب زیر (&lt;a title="How to avoid relying on github: mirror your repository" href="http://www.deanclatworthy.com/2013/01/how-to-avoid-relying-on-github-mirror-your-repository/" target="_blank"&gt;منبع&lt;/a&gt;) را پیدا کردم که خیلی جالب و کمکی به نظرم آمد. تست کردم‌، فوق‌العاده بود. پس ترجمه‌اش را این‌جا می‌گذارم تا شما هم حالی ببرید از آخرین فرزند خلف آقایمان‌، ترووالدز ;-)&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;یکی از نکاتی که قطعی‌های اخیر گیت‌هاب گوشزد می‌کنند این است که گیت به عنوان یک سیستم مدیریت نسخهٔ غیر متمرکز طراحی شده. بسیاری از مردم به این صورت آن را مورد استفاده قرار نمی‌دهند. به جای داشتن چند بایگانی راه دور‌، داده‌ها را به یک جا می‌فرستند و در اصل بیش از اندازه به گیت‌هاب تکیه می‌کنند. کسانی را دیده‌ام که کل سازمان‌شان را بر پایهٔ گیت‌هاب بنا کرده‌اند‌، چیز‌هایی نظیر گسترش اسکریپت‌های سایت‌شان و نصب اسکریپ‌ها برای توسعه دهندگان جدید‌شان. علاوه بر این‌، dependency manager‌هایی مثل Composer و Cocoapods نیز به گیت‌هاب وابسته‌اند تا پیش‌نیاز‌هایشان را دریافت کنند. اگر گیت‌هاب Down شود‌، شما نمی‌توانید پیش‌نیاز‌های‌تان را دستکاری کنید و یا نمونه‌های جدید‌تری به آن‌ها اضافه کنید. در یک دنیای ایده‌آل این Dependency manager‌ها باید قابلیت‌ پشتیبانی توکار از mirror‌ها را داشته باشند‌، ولی در حال حاضر من چنین قابلیت‌هایی را نمی‌بینم.&lt;/p&gt;
&lt;p&gt;چیزی که من می‌خواهم انجام دهم این است که نشان‌تان دهم که چقدر آسان است که با استفاده از سرور‌های راه دور گیت در آن واحد به دو سرور مختلف داده‌های‌تان را ارسال کنید. اگر گیت‌هاب Down شد‌، مهم نیست‌، بر فرض این که همه افراد تیم‌تان از این راهنما پیروی کرده باشند‌، کد از طریق bitbucket نیز در دسترس خواهد بود‌، یا هر جای دیگری که شما انتخاب کرده‌اید. اما این راهنما از گیت‌هاب و بیت‌باکت به عنوان mirror استفاده می‌کند.&lt;/p&gt;
&lt;p&gt;۱. اول فرض می‌کنم که شما یک سرور راه دور برای گیت‌هاب به عنوان "origin" ایجاد کرده‌اید. آن را به github تغییر نام دهید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;git remote rename origin github
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;۲. یک مخزن جدید روی بیت‌باکت هم‌نام همان چیزی که در گیت‌هاب دارید بسازید.&lt;/p&gt;
&lt;p&gt;۳. این مخزن جدید را به صورت زیر به سرور‌های راه دور‌تان اضافه کنید. ولی مطمئن باشید که اسمش bitbucket باشد و نه origin. این‌طور:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;git remote add bitbucket ssh://git@bitbucket.org/username/somerepo.git

git push -u bitbucket --all
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;۴. و حالا با یک ادیتور از شاخهٔ ‎.git در مخزن گیت‌تان فایل config را باز کنید.&lt;/p&gt;
&lt;p&gt;۵. نوبت این است که url‌های مربوط به هر سرور راه دور را به مجموعهٔ جدیدی به اسم origin اضافه کنیم. می‌شود چیزی شبیه این:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;[&lt;/span&gt;remote &lt;span class="s2"&gt;"origin"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; git@github.com:username/somerepo.git

&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; ssh://git@bitbucket.org/username/somerepo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;۶. دفعهٔ بعد که از دستور git push origin استفاده کردید‌، مخزن در هر دو سرور راه دور آپلود خواهد شد.&lt;/p&gt;
&lt;p&gt;به همین راحتی.&lt;/p&gt;
&lt;p&gt;نسخه‌های اخیر گیت این اجازه را به شما می‌دهند که چند جا را به عنوان مخزن راه دور یک مجموعه معرفی کنید. ولی من ترجیح می‌دهم که ببینم چه کاری انجام می‌دهم.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;نکته از شاهینیسم:&lt;/strong&gt; بهتر است از یک public-key برای گیت‌هاب و بیت‌باکت استفاده کنید. این‌طوری مرحلهٔ شناسایی هر دو سرور مثل هم خواهد بود ;-)&lt;/p&gt;</description><category>bitbucket</category><category>git</category><category>github</category><category>اینترنت</category><category>برنامه نویسی</category><category>لینوس ترووالدز</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13911103chtwr-z-wbstgy-bh-gythb-frr-khnym-p.html</guid><pubDate>Tue, 22 Jan 2013 13:27:28 GMT</pubDate></item><item><title>expect دستیار باهوش شما در شل اسکریپت‌ها!</title><link>http://shahinism.github.io/posts/blog13911021expect-dstyr-bhwsh-shm-dr-shl-skhrypth.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;اگر تا به حال شل اسکریپت نوشته باشید‌، اگر حد اعتیادتان به آن اندازه باشد که بخواهید هر کاری را آسان‌تر کنید‌، اگر تنبلی‌تان گرفته باشد که بعد از آسان شدن کار‌هایتان با یک شل اسکریپت‌، رمز‌های جاهای مختلف را به یاد آورید تا اسکریپت‌تان درست کار کند‌‌، یا آن‌قدر به مغزتان فشار آورید که جواب صحیح یک سوال اسکریپت را پیدا کنید‌، آن وقت‌ می‌توانید درک کنید که expect چه ابزار خارق‌العاده‌ای است.
کار expect خیلی ساده است‌، بعد از اجرای اسکریپت‌تان‌، منتظر می‌ماند که اتفاق خاصی رخ دهد‌، مثلا دستوری در اسکریپت از شما رمز بخواهد‌، آن وقت expect وارد میدان می‌شود و رمز را وارد می‌کند. یعنی دیگر نیازی نیست که شما دخالتی داشته باشید. اگر فکر می‌کنید که خوب این که کار سختی نیست و از این حرف‌ها که خوب اول باید بگویم که کور خوانده‌اید و دوم این که بی‌خیال ادامهٔ این متن شوید ;-)&lt;/p&gt;
&lt;p&gt;حالا شیوهٔ عملکرد expect معلوم شد‌، بهتر است نگاهی بیاندازیم به وضعیت من. بنا به دلایل کاملا غیر عادی و نامعلومی‌، در کشوری کاملا آزاد‌، نیاز دارم که از sshuttle برای انجام برخی امور استفاده کنم. این برنامه برای انجام دادن درست کار‌هایش‌، نیاز به iptables دارد که خوب من دوست ندارم که کاربر عادی‌ام به آن دسترسی داشته باشد. پس همین دوست نداشتن من یک مرحلهٔ اضافه در فرآیند استفاده از sshuttle هزینه دارد. یعنی یک همچین چیزی:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;su

Vared Kardan Ramz

&lt;span class="nb"&gt;cd&lt;/span&gt; /home/shahin/bin/sshutle

./sshuttle ...

Vared Kardan Ramz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;که خوب بعد از اولین تلاش کانکت نمی‌شود و باید دوباره دستور را بزنم و منتظر بمانم تا پرامپت رمز ssh ظاهر شود و باقی قضایا. خوب کمی سخت است. البته این را هم اضافه کنم که خوب می‌دانم می‌توانم کانکت بدون رمز ssh داشته باشم‌. می‌توانم دستور را درون یک path قرار دهم. می‌توانم‌، می‌توانم‌… ولی این روشی است که من کار می‌کنم ;-)&lt;/p&gt;
&lt;p&gt;این است که دست به دامن expect می‌شوم و همچین اسکریپتی می‌نویسم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/expect -f&lt;/span&gt;



&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;{[&lt;/span&gt;llength &lt;span class="nv"&gt;$argv&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; 5&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    puts &lt;span class="s2"&gt;"usage: ssh.exp client_root_pass username password server port"&lt;/span&gt;
&lt;span class="nb"&gt;exit &lt;/span&gt;1

&lt;span class="o"&gt;}&lt;/span&gt;



&lt;span class="nb"&gt;set &lt;/span&gt;rootpass &lt;span class="o"&gt;[&lt;/span&gt;lrange &lt;span class="nv"&gt;$argv&lt;/span&gt; 0 0&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nb"&gt;set &lt;/span&gt;username &lt;span class="o"&gt;[&lt;/span&gt;lrange &lt;span class="nv"&gt;$argv&lt;/span&gt; 1 1&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nb"&gt;set &lt;/span&gt;password &lt;span class="o"&gt;[&lt;/span&gt;lrange &lt;span class="nv"&gt;$argv&lt;/span&gt; 2 2&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nb"&gt;set &lt;/span&gt;server &lt;span class="o"&gt;[&lt;/span&gt;lrange &lt;span class="nv"&gt;$argv&lt;/span&gt; 3 3&lt;span class="o"&gt;]&lt;/span&gt;

&lt;span class="nb"&gt;set &lt;/span&gt;port &lt;span class="o"&gt;[&lt;/span&gt;lrange &lt;span class="nv"&gt;$argv&lt;/span&gt; 4 4&lt;span class="o"&gt;]&lt;/span&gt;



&lt;span class="nb"&gt;set &lt;/span&gt;timeout -1



spawn su -c &lt;span class="s2"&gt;"/home/shahin/bin/sshuttle/sshuttle --dns -r $username@$server:$port 0/0 -vv"&lt;/span&gt;

match_max 100000

expect &lt;span class="s2"&gt;"Password:*"&lt;/span&gt;

send -- &lt;span class="s2"&gt;"$rootpass\r"&lt;/span&gt;



expect &lt;span class="s2"&gt;"*?assword:*"&lt;/span&gt;

send -- &lt;span class="s2"&gt;"$password\r"&lt;/span&gt;

send -- &lt;span class="s2"&gt;"\r"&lt;/span&gt;

expect eof
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا همانطور که معلوم است کافی است همچین دستوری را تایپ کنم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;./ssh.exp client_root_pass username password server port
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا می‌شود این اسکریپت را بدون هیچ ضرر اضافه‌ای به path اضافه کرد و حالش را برد. برای این که بفهمید این اسکریپت چطور کار می‌کند راهنما‌های زیادی در اینترنت می‌یابید. man page خود برنامه هم می‌تواند کمک خوبی باشد. ضمن این که اگر اسکریپت نویسی بدانید‌، چیز زیادی برای یاد گرفتن پیش‌رویتان نیست ;-)&lt;/p&gt;</description><category>expect</category><category>iptables</category><category>sshuttle</category><category>برنامه نویسی</category><category>حل مشکل</category><category>شل اسکریپت</category><category>نرم افزار</category><category>گنو/لینوکس</category><guid>http://shahinism.github.io/posts/blog13911021expect-dstyr-bhwsh-shm-dr-shl-skhrypth.html</guid><pubDate>Thu, 10 Jan 2013 15:09:09 GMT</pubDate></item><item><title>دریافت اطلاعات سیستم بدون استفاده از Conky، یا چطور با عصای جادو‌ی لینوکس یک Conky بسازیم!</title><link>http://shahinism.github.io/posts/blog13910904dryft-tlt-systm-bdwn-stfdh-z-conky.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;همانطور که می‌دانید‌، چند ماهی می‌شود که از i3 استفاده می‌کنیم‌، ولی در i3bar به جای i3status (به دلیل سادگی بیش از اندازه‌اش D:) از Conky بهره می‌گیرم. کانکی اطلاعات خیلی خوبی ارائه می‌دهد و کار‌های جالبی هم می‌توان روی خروجی‌اش انجام داد‌. ولی وقتی قرار است آن را به i3status بخورانم‌، باید از آپشن shell روی Conky استفاده کنم که دیگر خبری از آن جینگولک بازی‌های معروف Conky نیست‌. همه چیز خیلی ساده می‌شود. تصویر زیر وضعیت فعلی i3barام را نشان می‌دهد‌:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://dl.dropbox.com/u/25017694/Blog-photos/ConkyOni3.png"&gt;&lt;img class=" " title="ConkyOni3" src="http://dl.dropbox.com/u/25017694/Blog-photos/ConkyOni3.png" alt="" width="540" height="44"&gt;&lt;/a&gt; برای دیدن در اندازهٔ بزرگ کلیک کنید&lt;/p&gt;
&lt;p&gt;و فعلا چند اشکال به آن وارد است‌: اول این که دارم از یک برنامهٔ خیلی گنده‌، برای یک کار ساده استفاده می‌کنم‌. دوم این که در حالت شل قدرت زیادی برای انگولک خروجی Conky ندارم (مثلا آن قسمت درصد استفاده از CPU برای درصد‌های مختلف تک رقمی‌، دو رقمی و سه رقمی‌، طول‌های متفاوتی می‌گیرد و کمی قضیه را لوس می‌کند) و سوم این که اگر به ماندن در همین وضعیت رضایت دهم‌، سوادم هیچ وقت زیاد نمی‌شود‌ D:&lt;/p&gt;
&lt;p&gt;پس تصمیم می‌گیرم که خروجی فعلی کانکی را (البته با چند تغییر کوچک) با ابزار ساده‌تری جایگزین کنم‌. خوب کار تقریبا پیچیده و سختی به نظر می‌رسد (وقتی که از لینوکس هیچ چیز ندانم) اما خوب همین Conky هم اطلاعاتش را از روی هوا نمی‌گیرد که! از طرفی مسالهٔ زبان پایش به میان می‌آید‌. به چه زبانی بنویسم؟ من که ته تهش پایتون را (آن هم دست و پا شکسته) می‌دانم‌.&lt;/p&gt;
&lt;p&gt;بعد از کمی جستجو و دو دو تا چهار تا با دانسته‌های قبلی‌ام‌، مساله را این‌طور حل می‌کنم (از راست به چپ تصویر):&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;زمان: روی توزیعم با دستور date می‌توانم زمان حاضر را به طور کامل ببینم و البته می‌توانم آن را به صورت دلخواهم فرمت کنم‌.&lt;/li&gt;
    &lt;li&gt;صدا: حقیقتش کشف کردم نیازی به این ندارم و زیاد دنبال واکشی مقدارش نگشتم‌. ولی مطمئنم یک راه ساده برای فهمیدنش هست ;-)&lt;/li&gt;
    &lt;li&gt;مجموع آپلود/دانلود نشست حاضر (TU/TD): خوب بعد از کمی جستجو‌، با دوست قدیمی ولی ناشناخته‌ام proc آشنا شدم‌، که از قرار خیلی خیلی‌، بیشتر از چیز‌هایی که می‌خواهم را بهم می‌رساند‌. فعلا ‎/proc/net/dev جواب تا این‌جای کار است‌.&lt;/li&gt;
    &lt;li&gt;سرعت دانلود/آپلود (D/U): راستش را بخواهید‌، این یکی مرا خیلی در کف نگه داشت‌! فکر می‌کردم باید جایی مثلا در proc برای این قضیه باشد‌. ولی نکته‌اش این‌جا بود که من اصلا نفهمیده بودم که چه می‌خواهم‌. که البته با تقلب از روی این &lt;a title="code-project-monitor-proc-python-and-clutter" href="http://www.tuxradar.com/content/code-project-monitor-proc-python-and-clutter" target="_blank"&gt;آموزش&lt;/a&gt; آن هم به صورت اتفاقی قضیه را درک کردم و شبیه سازی (البته نکاتی هم باقی می‌ماند که در ادامه مطرح می‌کنم).&lt;/li&gt;
    &lt;li&gt;وضعیت رم: خوب این یکی هم مثل date. می‌دانستم که دستوری به اسم free برای این‌کار ساخته شده‌. ولی باید کمی خروجی‌اش را انگولک می‌کردم و چیزی که می‌خواستم را بیرون می‌کشیدم.&lt;/li&gt;
    &lt;li&gt;وضعیت CPU: این یکی ترکیبی از همهٔ کار‌هاییست که در بالا باید انجام دهم به علاوه کلی چیز جدید که باید یاد بگیرم‌. فایل ‎/proc/stat وضعیت فعلی CPU را در خودش نگه می‌دارد که با اسکریپتی که در &lt;a title="cpu usage monitor script on github" href="https://github.com/moisespsena/linux-cpu-usage/blob/master/cpu-usage-monitor.sh" target="_blank"&gt;این‌جا&lt;/a&gt; دیدم فهمیدم که چطور وضعیت کل CPU را واکشی کنم‌. اما من وضعیت کل را نمی‌خواستم‌، بلکه به دنبال وضعیت تک تک هسته‌ها بودم که خوب باید دست و بالم رو کثیف‌تر می‌کردم ;-)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;خوب تمام این کار‌ها را می‌شود با پایتون هم انجام داد (با هر زبان دیگری هم می‌شود) ولی‌، دم دستی‌ترین چیز ممکن shell scripting است‌. هم احتمالا کمتر از مفسر پایتون به سیستم فشار می‌آورد و هم این که اصلا چیزی در موردش نمی‌دانم (نه این که اصلا‌، ولی نه در حد یک اسکریپت نویس ;-)). این می‌شود که طی دو روز گذشته‌، تمام فکر و ذکرم را می‌گذارم روی نوشتن این اسکریپت‌، تا هم چیز یاد بگیرم‌، و هم مستقل‌تر شوم ;-)&lt;/p&gt;
&lt;p&gt;اسکریپت حاضر است و از &lt;a title="sysdata script on github" href="https://github.com/shahinism/Scripts/blob/master/Shell/sysdata.sh" target="_blank"&gt;این‌جا&lt;/a&gt; قابل دریافت. در ادامه ذره‌، ذره به بررسی‌اش می‌پردازیم‌:&lt;/p&gt;
&lt;h5&gt;تاریخ&lt;/h5&gt;

&lt;p&gt;خوب اولین چیزی که لازم داشتیم‌، خروجی گرفتن زمان فعلی سیستم بود که گفتیم با دستور date قادر به انجامش هستیم‌. به صورت زیر:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nv"&gt;date&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date +&lt;span class="s2"&gt;"%a %Y.%m.%d %H:%M"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;نکتهٔ این دستور آن‌جاست که من برای مقدار دهی به متغیر date، از خروجی یک دستور استفاده کرده‌ام (کاری که در ادامه خیلی زیاد انجام می‌دهم‌). برای این کار کافیست دستور مورد نظر را در ‎$(‎)‎ بنویسیم‌. به همین راحتی!&lt;/p&gt;
&lt;h5&gt;اطلاعات شبکه&lt;/h5&gt;

&lt;p&gt;اولین چیز‌هایی که می‌خواهیم‌، این است که بفهمیم چقدر دانلود یا آپلود کرده‌ایم‌. که همانطور که گفتم این اطلاعات را در فایل ‎/proc/net/dev می‌توان یافت‌. همینطور‌، با محاسبهٔ این که در یک ثانیهٔ گذشته‌، چقدر دانلود/آپلود کرده‌ایم‌، می‌توان سرعت دانلود بر ثانیه را محاسبه کرد. این است که برای تمیزی کار‌، اول یک تابع می‌نویسیم که از proc ذکر شده‌، مقدار بایت‌های ارسالی یا دریافتی را واکشی کند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;function &lt;/span&gt;getNetBytes

&lt;span class="o"&gt;{&lt;/span&gt;

&lt;span class="nv"&gt;Brecived&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;cat &lt;span class="nv"&gt;$netInterface&lt;/span&gt; | grep &lt;span class="s2"&gt;"eth0"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{print($2)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;Btransmited&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;cat &lt;span class="nv"&gt;$netInterface&lt;/span&gt; | grep &lt;span class="s2"&gt;"eth0"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{print($10)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;متغیر ‎$netInterface اشاره به همان فایل ‎/proc/net/dev می‌کند که در اول اسکریپت تعریفش کرده‌ام‌. بعد هم با grep تنها خطی که مربوط به اینترفیسی که می‌خواهم است را جدا می‌کنم (eth0) و حالا با awk خانهٔ شمارهٔ ۲ را برای بایت‌های دریافت شده‌، و خانهٔ شمارهٔ ۱۰ این خروجی را برای بایت‌های فرستاده شده جدا می‌کنم‌. این کار را به روش‌های دیگری هم می‌شد انجام داد‌، ولی به نظرم با این روش‌، خط‌های کمتری تایپ کردم ;-)&lt;/p&gt;
&lt;p&gt;حالا با دستورات زیر‌، چیز‌هایی که می‌خواهم را محاسبه می‌کنم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nv"&gt;dlSpeed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$((&lt;/span&gt; &lt;span class="nv"&gt;$Brecived&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$oldBRecived&lt;/span&gt; &lt;span class="k"&gt;))&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $1/1024)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;upSpeed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$((&lt;/span&gt; &lt;span class="nv"&gt;$Btransmited&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$oldBTransmited&lt;/span&gt; &lt;span class="k"&gt;))&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $1/1024)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;traffic&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"$Brecived $Btransmited"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", ($1+$2)/1024/1024 )}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;طی این دستورات‌، از قابلیت متغیر‌گیری به صورت ‎$num و همینطور‌، پرینت فرمت شده (برای نمایش حداکثر دو رقم اعشار) awk استفاده کرده‌ام. این کار‌ها با dc هم قابل انجام بود‌، ولی خروجی به تمیزی awk نبود‌. همانطور که می‌بینید در این دستورات از متغیر‌های ‎$oldBRecived و ‎$oldBTransmited استفاده شده‌ که در واقع وضعیت یک ثانیه قبل دانلود/آپلود را در خود نگاه می‌دارند‌. تنها کافیست دستورات فوق را هر یک ثانیه اجرا کنیم تا خروجی درست را بگیریم‌. (حلقهٔ کامل این دستورات در آخر مطلب توضیح داده می‌شود)&lt;/p&gt;
&lt;p&gt;نکته‌ای که می‌ماند دقت این محاسبه است‌. حقیقتش همانطور که گفتم من این روش را از این‌جا [link] یاد گرفتم. اما دقیقا همان را پیاده سازی نکردم. مساله سر زمان محاسبه بود. نمی‌دانم چرا نویسنده در آن‌جا از epoch (تاریخ ۱/۱/۱۹۷۰) استفاده کرده بود (خوشحال می‌شوم اگر کسی می‌داند به من هم توضیح دهد‌.) نویسنده در آن‌جا می‌گوید مساله سر چند کیلوبایت است و از این حرف‌ها!&lt;/p&gt;
&lt;h5&gt;وضعیت RAM&lt;/h5&gt;

&lt;p&gt;گفتم که دستور free -m این‌کارها را انجام می‌دهد‌، پس:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;function &lt;/span&gt;getRamInfo

&lt;span class="o"&gt;{&lt;/span&gt;

&lt;span class="nv"&gt;totalMemory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;free -m | grep &lt;span class="s2"&gt;"Mem:"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $2/1024)}'&lt;/span&gt; &lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;usedMemory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;free -m | grep &lt;span class="s2"&gt;"buffers/cache"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $3/1024)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;memInPercent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"$totalMemory $usedMemory"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.0f", $2/($1/100)) }'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;فکر نکنم نکته‌ای باقی مانده باشد که قبلا توضیح نداده باشم‌. پس دیگر توضیح نمی‌دهم!&lt;/p&gt;
&lt;h5&gt;وضعیت CPU&lt;/h5&gt;

&lt;p&gt;خوب گفتم که برای یادگیری این کار‌، از این اسکریپت[link] استفاده کردم. ولی این اسکریپت تنها وضعیت کل CPU را بر می‌گرداند‌. من آن را طوری تغییر دادم که هر بار‌، آدرس هسته‌ای که می‌خواهم اطلاعاتش را بدانم در ورودی بگیرد‌، و فقط همان را هسته را محاسبه کند و در خروجی نشان دهد:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;function &lt;/span&gt;getCpuInfo&lt;span class="o"&gt;()&lt;/span&gt;

&lt;span class="o"&gt;{&lt;/span&gt;

&lt;span class="nv"&gt;CORE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;

&lt;span class="nv"&gt;addr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"^cpu${CORE}"&lt;/span&gt;

&lt;span class="nb"&gt;local &lt;/span&gt;&lt;span class="nv"&gt;CPU&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;cat /proc/stat | grep &lt;span class="nv"&gt;$addr&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# Get the total CPU statistics.&lt;/span&gt;

&lt;span class="nb"&gt;unset &lt;/span&gt;CPU&lt;span class="o"&gt;[&lt;/span&gt;0&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# Discard the "cpu" prefix.&lt;/span&gt;

&lt;span class="nb"&gt;local &lt;/span&gt;&lt;span class="nv"&gt;IDLE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;CPU&lt;/span&gt;&lt;span class="p"&gt;[4]&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# Get the idle CPU time.&lt;/span&gt;



&lt;span class="c"&gt;# Calculate the total CPU time.&lt;/span&gt;

&lt;span class="nb"&gt;local &lt;/span&gt;&lt;span class="nv"&gt;TOTAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="k"&gt;for &lt;/span&gt;VALUE in &lt;span class="s2"&gt;"${CPU[@]}"&lt;/span&gt;; &lt;span class="k"&gt;do&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"TOTAL=$TOTAL+$VALUE"&lt;/span&gt;

&lt;span class="k"&gt;done&lt;/span&gt;



&lt;span class="c"&gt;# Catch current cores last state&lt;/span&gt;

&lt;span class="nv"&gt;PREV_IDLE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval echo&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_IDLE&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;PREV_TOTAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval echo&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_TOTAL&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;



&lt;span class="c"&gt;# Calculate the CPU usage since we last checked.&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_IDLE=$IDLE-$PREV_IDLE"&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_TOTAL=$TOTAL-$PREV_TOTAL"&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_USAGE=(1000*($DIFF_TOTAL-$DIFF_IDLE)/$DIFF_TOTAL+5)/10"&lt;/span&gt;



&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_TOTAL&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"$TOTAL"&lt;/span&gt;

&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_IDLE&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"$IDLE"&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;برای این کار از یک متغیر برای تابع استفاده می‌کنم و مقدارش را به متغیر CORE اختصاص می‌دهم‌. با استفاده از این آدرس یک عبارت با قائده (Regex) به صورت "‎^cpu${CORE}‎" می‌سازم‌. این عبارت باقائده با خطوطی که در اولشان عبارت cpuN را دارند مطابقت می‌کند‌. و سپس با استفاده از داده‌هایی که دارم یک آرایه با استفاده از پردازش فایل ‎/proc/stat می‌سازم و آن را به متغیر CPU نسبت می‌دهم‌. خوب حالا چون اولین خانهٔ این آرایه اسم CPU را دارد‌، و به درد محاسبات بعدی نمی‌خورد‌، آن را از آرایه بیرون می‌اندازم (unset CPU[0]‎) و همین‌طور مقدار خانهٔ IDLE را هم در متغیری به همین نام ذخیره می‌کنم‌.&lt;/p&gt;
&lt;p&gt;با جمع کردن تمامی مقادیر موجود در آرایهٔ CPU می‌توانم کل وضعیت کارکرد CPU را به دست آورم‌. این می‌شود که به صورت زیر این کار را انجام می‌دهم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nb"&gt;local &lt;/span&gt;&lt;span class="nv"&gt;TOTAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="k"&gt;for &lt;/span&gt;VALUE in &lt;span class="s2"&gt;"${CPU[@]}"&lt;/span&gt;; &lt;span class="k"&gt;do&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"TOTAL=$TOTAL+$VALUE"&lt;/span&gt;

&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ساده است این‌طور نیست؟ آن let آن‌جا همان کار ‎(())$ را می‌کند‌. حالا وقت انجام محاسبات است‌. چون هر بار نیاز است که وضعیت قبلی CPU مورد نظر را داشته باشیم‌، پس لازم است برای هر CPU متغیر‌های مربوطه را بسازیم‌. که این کار را با دستورات زیر انجام می‌دهیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_TOTAL&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"$TOTAL"&lt;/span&gt;

&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_IDLE&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"$IDLE"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;این دستور eval فوق‌العاده است‌. با استفاده از آدرس CPU فعلی (CORE) متغیر‌های مورد نظرم را می‌سازد و مقادیر مربوطه را درشان ذخیره می‌کند‌. اما چون نمی‌خواهم زیادی کثیف کاری شود‌، قبل از انجام محاسبات‌، متغیر‌هایی که ساخته‌ایم را به یک نام ثابت در می‌آورم تا کارم را آسان کنم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nv"&gt;PREV_IDLE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval echo&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_IDLE&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;PREV_TOTAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;eval echo&lt;/span&gt; &lt;span class="se"&gt;\P&lt;/span&gt;REV_TOTAL&lt;span class="nv"&gt;$CORE&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا این دو متغیر‌، وضعیت قبلی CPU را در خود نگه می‌دارند‌. پس نوبت این است که محاسباتم را انجام دهم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_IDLE=$IDLE-$PREV_IDLE"&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_TOTAL=$TOTAL-$PREV_TOTAL"&lt;/span&gt;

&lt;span class="nb"&gt;let&lt;/span&gt; &lt;span class="s2"&gt;"DIFF_USAGE=(1000*($DIFF_TOTAL-$DIFF_IDLE)/$DIFF_TOTAL+5)/10"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;چیز خاصی نیست دیگر‌، همه چیز روشن است ;-)&lt;/p&gt;
&lt;h5&gt;پایان کار&lt;/h5&gt;

&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;;

&lt;span class="k"&gt;do&lt;/span&gt;

getNetBytes

getRamInfo

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt; &lt;span class="nv"&gt;COUNT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0; COUNT &amp;amp;lt; &lt;span class="nv"&gt;$CORES&lt;/span&gt;; COUNT++ &lt;span class="o"&gt;))&lt;/span&gt;;&lt;span class="k"&gt;do&lt;/span&gt;

getCpuInfo &lt;span class="nv"&gt;$COUNT&lt;/span&gt;

&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="se"&gt;\c&lt;/span&gt;pu&lt;span class="nv"&gt;$COUNT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$DIFF_USAGE&lt;/span&gt;

&lt;span class="k"&gt;done&lt;/span&gt;



&lt;span class="nv"&gt;dlSpeed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$((&lt;/span&gt; &lt;span class="nv"&gt;$Brecived&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$oldBRecived&lt;/span&gt; &lt;span class="k"&gt;))&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $1/1024)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;upSpeed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;$((&lt;/span&gt; &lt;span class="nv"&gt;$Btransmited&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$oldBTransmited&lt;/span&gt; &lt;span class="k"&gt;))&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", $1/1024)}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;traffic&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"$Brecived $Btransmited"&lt;/span&gt; | awk &lt;span class="s1"&gt;'{printf( "%.2f", ($1+$2)/1024/1024 )}'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;



&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;

&lt;span class="s2"&gt;"CPU: %3s,%3s,%3s,%3s | RAM: %sG/%sG (%s%%) | LAN: ↓: %4sƘ ↑: %4sƘ T↕: %6s | %s\n"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;

&lt;span class="s2"&gt;"$cpu0"&lt;/span&gt; &lt;span class="s2"&gt;"$cpu1"&lt;/span&gt; &lt;span class="s2"&gt;"$cpu2"&lt;/span&gt; &lt;span class="s2"&gt;"$cpu3"&lt;/span&gt; &lt;span class="s2"&gt;"$usedMemory"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;

&lt;span class="s2"&gt;"$totalMemory"&lt;/span&gt; &lt;span class="s2"&gt;"$memInPercent"&lt;/span&gt; &lt;span class="s2"&gt;"$dlSpeed"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;

&lt;span class="s2"&gt;"$upSpeed"&lt;/span&gt; &lt;span class="s2"&gt;"$traffic"&lt;/span&gt; &lt;span class="s2"&gt;"$date"&lt;/span&gt;

&lt;span class="nv"&gt;oldBRecived&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$Brecived&lt;/span&gt;

&lt;span class="nv"&gt;oldBTransmited&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$Btransmited&lt;/span&gt;

sleep 1

&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا نوبت این است که کار را تمام کنم‌. یک حلقهٔ همیشه درست می‌سازم و فقط بهش می‌گویم بعد از این که همهٔ کار‌هایت را انجام دادی یک ثانیه استراحت کن (برای این که سرعت اینترنت را درست محاسبه کند‌، این مقدار ضروری است). بر همین اساس تابع‌های getNetBytes و getRamInfo را صدا می‌کنم تا متغیر‌های جدیدشان را تولید کنند‌. اما در مورد تابع getCpuInfo قضیه کمی فرق دارد‌. قرار است که چهار بار این تابع را با متغیر‌های متفاوت صدا کنیم و نتیجهٔ حاصله‌اش را در متغیرهای جداگانه ذخیره کنیم‌. این است که آن حلقهٔ for سر و کله‌اش پیدا می‌شود‌. یک حلقهٔ for به سبک C که خداییش به نظرم کامل‌ترین حلقه‌های for است D: حالا تابع را درش به صورت getCpuInfo $COUNT صدا می‌زنم و متغیر ‎$DIFF_USAGE که همان طرصد مصرف است را به یک متغیر به صورت cpuN نسبت می‌دهم‌. این N همان آدرس هسته است.&lt;/p&gt;
&lt;p&gt;همان‌طور که می‌بینید در ادامه محاسبهٔ سرعت اینترنت می‌آید که قبلا توضیحش داده‌ام‌. printf را فعلا ول کنید و به دو خط بعدش نگاهی کنید‌. همان دو متغیری که وضعیت قبلی ترافیک را نگه می‌دارند‌. فکر کنم دیگر همه چیز روشن شده باشد‌.&lt;/p&gt;
&lt;p&gt;حالا برسیم به آن printf. حتما می‌پرسید چرا از echo استفاده نکردم‌. echo خوب است‌، ولی خیلی ساده هم هست‌. آن مشکل کنترل فضای پرینت که در Conky گرفتارش بودم‌، این‌جا هم پیدا می‌شد‌. یک نگاهی به این خروجی بیاندازید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;CPU: 48,3,40,3 | RAM: 1.11G/1.95G &lt;span class="o"&gt;(&lt;/span&gt;57%&lt;span class="o"&gt;)&lt;/span&gt; | LAN: ↓:0.00Ƙ ↑:0.00Ƙ T↕:221.20 | Sat 2012.11.24 14:41

CPU: 8,4,76,4 | RAM: 1.11G/1.95G &lt;span class="o"&gt;(&lt;/span&gt;57%&lt;span class="o"&gt;)&lt;/span&gt; | LAN: ↓:0.00Ƙ ↑:0.00Ƙ T↕:221.20 | Sat 2012.11.24 14:41

CPU: 24,5,64,6 | RAM: 1.11G/1.95G &lt;span class="o"&gt;(&lt;/span&gt;57%&lt;span class="o"&gt;)&lt;/span&gt; | LAN: ↓:0.00Ƙ ↑:0.00Ƙ T↕:221.20 | Sat 2012.11.24 14:41
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;می‌بینید‌، هنوز هم طول خروجی کم و زیاد می‌شود که اصلا خوب نیست‌. این است که باید دنبال دستوری باشم که خروجی را آرایش کند و بیرون بدهد‌. printf سالاری که از زمان یادگیری C می‌شناسم این کار را برایم می‌کند‌. کافیست فضای متغیر‌ها را به صورت ‎%Ns که N همان طول مینیموم رشته است را مشخص کنم‌. خودش باقی کار‌ها را انجام می‌دهد‌. خوب همین دیگر‌. کارمان تمام شد‌. مرحلهٔ بعدی این است که یک خروجی json دار درست حسابی بسازم که i3 بتواند رنگی رنگی‌اش کند ;-)&lt;/p&gt;
&lt;p&gt;&lt;a href="http://dl.dropbox.com/u/25017694/Blog-photos/SysdataOni3.png"&gt;&lt;img title="SysdataOni3" src="http://dl.dropbox.com/u/25017694/Blog-photos/SysdataOni3.png" alt="" width="527" height="50"&gt;&lt;/a&gt; برای دیدن در اندازهٔ بزرگ‌تر کلیک کنید&lt;/p&gt;</description><category>awk</category><category>bash</category><category>printf</category><category>shell scripting</category><category>بررسی</category><category>برنامه نویسی</category><category>حل مشکل</category><category>دسته‌بندی نشده</category><category>نرم افزار</category><category>کدباز</category><category>گنو/لینوکس</category><guid>http://shahinism.github.io/posts/blog13910904dryft-tlt-systm-bdwn-stfdh-z-conky.html</guid><pubDate>Sat, 24 Nov 2012 15:07:09 GMT</pubDate></item><item><title>تبدیل PDF فارسی به متن با استفاده از چند ابزار لینوکسی و کمی پایتون</title><link>http://shahinism.github.io/posts/blog13910902tbdyl-pdf-frsy-bh-mtn-b-stfdh-z-chnd-b.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;همین اول کار بگویم که این روش تنها مخصوص موقعی است که PDF به صورت دیجیتالی تولید شده باشد و کاراکتر‌ها تصویر نباشند‌‌، که خوب برای کاراکتر‌های تصویری‌، نیاز به روش‌های اپتیکال است که فعلا در این بحث ما نمی‌گنجد‌. &lt;del&gt;برای نمونه من از کتاب _* که معرفی دوست خوبم &lt;a title="وبلاگ شخصی ایمان" href="http://emanlog.com" target="_blank"&gt;ایمان&lt;/a&gt; است استفاده می‌کنم‌.&lt;/del&gt; نمونهٔ اولیه بنا به دلایلی معلوم با&lt;a title="Ashamloo" href="http://dl.dropbox.com/u/25017694/Blog_files/Ahanha_Va_Ehsas_(www.txt.ir).pdf"&gt; کتابی&lt;/a&gt; از احمد شاملو عوض شد!
اول از همه PDF را با برنامهٔ PDFخوان پیش‌فرض میزکار KDE یعنی Okular باز می‌کنیم‌. یک نگاه به قد و بالایش می‌اندازیم و سپس از منوی فایل‌، گزینهٔ Export as و سپس Plain text را انتخاب می‌کنیم‌. خروجی این عمل ما یک فایل متنی است که فکر می‌کنیم همه کار را به درستی انجام داده‌. (البته من که اول اصلا فکرش را هم نمی‌کردم که بتوان خروجی فارسی گرفت) در نگاه اول کارمان تمام شده است‌. ولی بگذارید آن را با یک ویرایشگر باز کنیم‌. آن را با ایمکس باز می‌کنم و از آن‌جایی که تنظیم فونت‌هایم را از روی روشی که فرود عزیز در stackoverflow&lt;a title="emacs font for western and other like rtl" href="http://stackoverflow.com/questions/11012627/emacs-font-for-western-and-other-like-rtl" target="_blank"&gt; پیشنهاد کرده‌&lt;/a&gt;، انجام داده‌ام نکته‌ای عجیب به نظر می‌رسد‌!&lt;/p&gt;
&lt;p&gt;مشکل این‌جاست که در ایمکس فونت سراسری‌ام متن فارسی را به صورت جدا جدا نشان می‌دهد‌. ولی طبق روشی که به آن اشاره کردم‌، کاراکتر‌هایی که در رنج خاصی از کد‌های یونیکد هستند‌، باید با فونت Tahoma (انتخاب من) نمایش داده شوند. اما وقتی فایل خروجی Okular را باز می‌کنم می‌بینم کاراکتر‌ها کاملا درست‌، ولی با فونتی غیر از تاهوما دیده می‌شوند‌. خوب تجربه ثابت کرده که هیچ مشکلی به این راحتی حل نمی‌شود‌. کمی از خروجی را به یک فایل tex تبدیل می‌کنم و خروجی PDFش را بررسی می‌کنم‌. خروجی تقریبا قابل قبول است ولی در بعضی از خطوط کاراکتر‌ها به صورت مبهمی به هم ریخته‌اند‌. از آن‌جایی که خودم برنامهٔ officeای روی سیستم ندارم و &lt;a title="وقتی دزدی می‌کن(م،ن،ید)" href="http://shahinism.com/blog/1391/08/25/%d9%88%d9%82%d8%aa%db%8c-%d8%af%d8%b2%d8%af%db%8c-%d9%85%db%8c%e2%80%8c%da%a9%d9%86%d9%85%d8%8c%d9%86%d8%8c%db%8c%d8%af/" target="_blank"&gt;وضع اینترنت‌ام&lt;/a&gt; هم معلوم است‌، از دوست &lt;a title="لیبره آفیس قدم رو" href="http://emanlog.com/?p=303" target="_blank"&gt;libreoffice کار قهارم&lt;/a&gt; می‌خواهم که فایل خروجی Okular را یک بار دیگر و این‌بار با libreoffice تست کند و ببیند آیا قابل ویرایش است یا نه‌؟ ایمان در جواب می‌گوید که کاراکتر‌ها مثل تصویر عمل می‌کنند و قدرت ویرایش چندانی روی آن‌ها ندارم.(اگر دروغ گفته‌، یقهٔ خودش رو بگیرید ;-))&lt;/p&gt;
&lt;p&gt;پس حالا نوبت این است که کمی دست‌هایمان را کثیف‌تر کنیم‌. مساله ساده است‌. فایلی داریم شامل کاراکتر‌هایی که امیدواریم حداقل یونیکد باشند‌، ولی می‌خواهیم آن‌ها را به رنج استانداردی که می‌شناسیم تبدیل کنیم (یک Find &amp;amp; Replace سریع و دوست داشتنی D:)‌. پایتون دوست‌داشتنی چند تابع خیلی‌، خیلی باحال برای کمک به ما در همچین وضعیت‌هایی دارد‌. اولی‌شان ord است‌. کارش این است که یک کاراکتر را به عنوان ورودی بگیرد و در خروجی کد معادلش را چاپ کند‌. دیگری unichr است که تقریبا کاری برعکس کار ord می‌کند‌. یک کد (که فکر می‌کند یونیکد است) در ورودی می‌گیرد‌، و کاراکتر یونیکد معادلش را در خروجی بر می‌گرداند‌.&lt;/p&gt;
&lt;p&gt;پس برای شروع کار چند تابع کوچک می‌نویسیم که برای دستکاری فایل کمک‌مان کند‌. تابع اول‌مان‌، چیزی است که در بقیه راه نیازش داریم‌. تابعی که یک فایل را از ورودی بخواند‌:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;def read_file&lt;span class="o"&gt;(&lt;/span&gt;file_name&lt;span class="o"&gt;)&lt;/span&gt;:

&lt;span class="nv"&gt;the_file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; codecs.open&lt;span class="o"&gt;(&lt;/span&gt;file_name, &lt;span class="nv"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"utf-8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;return &lt;/span&gt;the_file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همین‌طور برای این که خیال‌مان راحت شود‌، تابعی می‌نویسیم که کل محتوای فایل ورودی‌اش را به صورت کاراکتر به کاراکتر (هر کاراکتر در یک خط) چاپ کند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;def show_characters&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;line in read_file&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;.readlines&lt;span class="o"&gt;()&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;char in line:

print char
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا نوبت بخش هیجان‌انگیز‌تر ماجرا می‌رسد‌. تابعی دیگر می‌نویسیم که این‌بار به جای کاراکتر‌ها‌، کد‌های معادل‌شان را چاپ کند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;def show_unicode_code&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;line in read_file&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;.readlines&lt;span class="o"&gt;()&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;char in line:

print ord&lt;span class="o"&gt;(&lt;/span&gt;char&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و سر‌انجام تابعی می‌نویسیم که عکس کار بالا را انجام دهد:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;def replace_unicode_char&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;line in read_file&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;.readlines&lt;span class="o"&gt;()&lt;/span&gt;:

print unichr&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="o"&gt;(&lt;/span&gt;line&lt;span class="o"&gt;))&lt;/span&gt;.encode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'utf-8'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;مطمئنا می‌شد این توابع را به صورت‌های ساده‌تری هم نوشت‌. ولی خوب اولا سواد من به همین‌قدر می‌رسید‌، دوما هم به نظرم برنامه خوانا‌تر شده‌. برای کسانی که پایتون می‌دانند به نظرم کد‌ها به قدر کافی گویا هستند (آن‌هایی هم که نمی‌دانند کافیست انگلیسی‌شان کفایت کند‌. نا سلامتی هنر پایتون همین است D:). فقط یک نکته در تابع replace_unicode_char باقی می‌ماند و آن هم این که کاراکتر‌های ورودی به صورت رشته هستند و قبل از خوراندنشان به unichar باید تبدیل به عدد (int) شوند‌. همینطور اگر می‌خواهید کاراکتر‌ها را در خروجی چاپ کنید‌، باید به صورت utf-8 کد کنید که خود دستور به قدر کافی گویا هست‌.&lt;/p&gt;
&lt;p&gt;من کل این توابع به علاوهٔ یک تابع مهم‌تر از آن‌ها را (که پایین‌تر توضیح‌اش می‌دهم) به صورت یک اسکریپت نوشته‌ام که می‌توانید از&lt;a title="لینک به اسکریپت chrvalidator.py" href="https://github.com/shahinism/Scripts/blob/master/Python/chrvalidator/chrvalidator.py" target="_blank"&gt; این‌جا &lt;/a&gt;دریافتش کنید‌. که خوب به عنوان راهنما اضافه کنم که در صورتی که خواستید فایل را به صورت کاراکتر به کاراکتر در خروجی ببینید از دستور زیر بهره بگیرید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;python chrvalidator.py -i INPUT_FILE -c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;اگر خواستید که کد‌های یونیکد کاراکتر‌هایش را ببینید از دستور زیر استفاده کنید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;python chrvalidator.py -i INPUT_FILE -u
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و اگر هم خواستید که بر عکس کار فوق (تبدیل کد‌های یونیکد به کاراکتر‌های نظیرشان) را انجام دهید‌، به جای ‎-u در دستور فوق از ‎-U استفاده کنید‌. خوب بگذارید به مسالهٔ اصلی‌مان برگردیم‌. برای شروع کار بیایید با دستورات زیر‌، لیستی از کد‌های کاراکتر استفاده شده در فایل‌مان به دست آوریم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;python chrvalidator.py -i ashamloo.txt -u &amp;amp;gt; chrcodes.txt

sort -u chrcodes.txt &amp;amp;gt; uniq.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب همان‌طور که معلوم است اول از همه کد تمام کاراکتر‌ها را استخراج کردیم‌. و سپس از آن‌جایی که مطمئنیم کاراکتر‌های تکراری زیادی داریم‌، و صد البته مطمئن‌تریم که یک فایل مرتب شده بیشتر به دردمان می‌خورد با استفاده از دستور sort -u کاراکتر‌های تکراری را حذف کرده و فایل را مرتب می‌کنیم‌. حالا همین فایل مرتب شده را دوباره به اسکریپت‌مان می‌خورانیم تا کاراکتر‌های نظیر‌شان را پیدا کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;python chrvalidator.py -i uniq.txt &amp;amp;gt; uniqchr.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;یک بررسی سرسری‌، نشان‌مان می‌دهد که تنها کاراکتر‌های محدودی از مجموع کاراکتر‌ها نیاز به تعویض دارند‌. دسته‌ای از کل کاراکتر‌ها مربوط به حروف انگلیسی یا اعدادند‌. دسته‌ای دیگر هم در این بین کاراکتر‌های استانداردند. و این وسط ما اکثرا نیاز به تغییر کاراکتر‌هایی موسوم به &lt;a title="unicode character table" href="http://www.ssec.wisc.edu/~tomw/java/unicode.html#xFE70" target="_blank"&gt;Arabic Presentation Forms-B&lt;/a&gt; داریم‌. خوب همانطور که می‌بینید در بین این کاراکتر‌ها برای نمونه حرف «ب» در سه حالت مختلف «اول‌، وسط‌، آخر» نمایش داده می‌شود که هر کدام کاراکتر مربوط به خود و در نتیجه کد مربوط به خود را دارند‌. برای همین ما تابعی دیگری نیز به صورت زیر به اسکریپت‌مان اضافه می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;for &lt;/span&gt;line in read_file&lt;span class="o"&gt;(&lt;/span&gt;input_file&lt;span class="o"&gt;)&lt;/span&gt;.readlines&lt;span class="o"&gt;()&lt;/span&gt;:

&lt;span class="k"&gt;for &lt;/span&gt;char in line:

&lt;span class="k"&gt;if &lt;/span&gt;ord&lt;span class="o"&gt;(&lt;/span&gt;char&lt;span class="o"&gt;)&lt;/span&gt; in &lt;span class="o"&gt;(&lt;/span&gt;64343, 64344, 64345&lt;span class="o"&gt;)&lt;/span&gt;:

&lt;span class="nv"&gt;char&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"پ"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در این تابع همان‌طور که پر واضح است‌، می‌گوییم فایل را کاراکتر به کاراکتر بخوان‌، کد دسیمال کاراکتر را پیدا کن‌، و اگر این کد دسیمال شبیه به یکی از سه عدد (کد‌های مربوط به حروف پ اول‌، وسط و آخر) بود آن را با حرف پ جایگزین کن‌. ساده است‌، این‌طور نیست؟ خوب من این کار را برای تقریبا چهل کاراکتر استاندارد انجام دادم که نتیجه‌اش در اسکریپت معلوم است (اگر شما خواستید فایل دیگری را به این روش تبدیل کنید و کاراکتری به این لیست اضافه کردید‌، خوشحال می‌شوم که اسکریپت تکمیل شده‌تان را با من و بقیه به اشتراک بگذارید‌)‌. در آخر کار هم با دستور زیر تابع را می‌بندیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;sys.stdout.softspace&lt;span class="o"&gt;=&lt;/span&gt;False

try:

print char.encode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"utf-8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;,

except UnicodeDecodeError:

print char,
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب خط اول این مجموعه مربوط به این است که به پایتون بفهمانیم در هنگام چاپ کاراکتر‌ها بین‌شان فاصله نگذارد‌. اگر این مقدار درست باشد‌، کاراکتر‌ها به صورت س ل ا م نوشته می‌شوند، که خوب به درد ما نمی‌خورد‌. همینطور ممکن است به دلیل این که بعضی اوقات در بین کاراکتر‌ها‌، کاراکتر به صورت utf-8 کد شده‌ای پیدا شود و خروجی را بشکند‌، با یک try, except جلوی این اتفاق را می‌گیریم‌، که یک کمی ممکن است گیج کنند باشد‌. در این مورد فقط به من اعتماد داشته باشید که اسکریپت کار می‌کند ;-)&lt;/p&gt;
&lt;p&gt;برای پایان کار هم فایل تکست اولیه‌مان را به صورت زیر با اسکریپت حاضرمان ویرایش می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;python chrvalidator.py -i ashamloo.txt &amp;amp;gt; validashamloo.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب کار تقریبا تمام شد‌. ولی خوب‌، کامپیوتر است دیگر‌. همیشه که درست عمل نمی‌کند‌. فایل خروجی نمونهٔ مرا در&lt;a title="ashamloo text file" href="http://dl.dropbox.com/u/25017694/Blog_files/ashamloo.txt.xz" target="_blank"&gt; این‌جا&lt;/a&gt; می‌بینید‌. خالی از اشکال هم نیست‌، ولی خوب طبیعتا مشکلات زیادی را برایم حل می‌کند (دیگر لازم نیست به آن فونت کذایی Arial زل بزنم). دیگر باقی کار‌ها می‌افتد گردن یک ویراستار به درد بخور‌. (البته شاید بتوان از &lt;a title="نسخهٔ جدید ویرایشگر متن نگار" href="http://shahinism.com/blog/1391/07/10/%d9%86%d8%b3%d8%ae%d9%87%d9%94-%d8%ac%d8%af%db%8c%d8%af-%d9%88%db%8c%d8%b1%d8%a7%db%8c%d8%b4%da%af%d8%b1-%d9%85%d8%aa%d9%86-%d9%86%da%af%d8%a7%d8%b1/" target="_blank"&gt;نگار&lt;/a&gt; هم کمک گرفت‌، که فعلا دارم شدیدا رویش کار می‌کنم‌. نسخهٔ فعلی‌اش مشکلاتی دارد‌، ولی امیدوارم بتوانم حل‌شان کنم‌)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;پی‌نوشت:&lt;/strong&gt; Okular از قرار‌، قادر نیست PDF‌هایی که رمزگذاری شده‌اند را باز کند (خودم امتحان نکردم) در آن صورت یک ابزار پایتونی برای این کار وجود دارد که در آینده در موردش می‌نویسم‌. تا این‌جای کار‌، خروجی‌های این تابع زیاد با روش ذکر شده همخوانی ندارد‌، پس باید به فکر دستکاری‌اش باشم‌. اسم این تابع هم در صورتی که دل‌تان می‌خواهد کشفش کنید pdfminer است.&lt;/p&gt;</description><category>KDE</category><category>LaTeX</category><category>ocr</category><category>okular</category><category>PDF</category><category>Python</category><category>tex</category><category>ایمکس</category><category>بررسی</category><category>برنامه نویسی</category><category>حل مشکل</category><category>نرم افزار</category><category>پایتون</category><category>کتاب</category><category>کدباز</category><category>گنو/لینوکس</category><guid>http://shahinism.github.io/posts/blog13910902tbdyl-pdf-frsy-bh-mtn-b-stfdh-z-chnd-b.html</guid><pubDate>Thu, 22 Nov 2012 14:31:08 GMT</pubDate></item></channel></rss>