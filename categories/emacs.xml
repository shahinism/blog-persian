<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>شاهینیسم (Emacs)</title><link>http://shahinism.github.io</link><description>بعضی وقت‌ها باید قبل از این که بتوانید راه بروید‌، بدوید‌!</description><lastBuildDate>Sun, 12 May 2013 19:37:33 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>این ایمکس دوست داشتنی (بالانس کردن پرانتز‌ها)</title><link>http://shahinism.github.io/posts/blog13920127yn-ymkhs-dwst-dshtny-blns-khrdn-prn.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از دلایل اصلی Syntax error‌ها بالانس نبودن پرانتز‌هاست (منظورم پرانتز‌، کروشه‌، آکولاد‌، &amp;lt;&amp;gt;‌، گیومه و … است). خوب از آن‌جایی که بنیاد ایمکس براساس Lisp است و Lisp به خاطر پرانتز‌هایش معروف شده (خیلی‌ها به شوخی می‌گن که Lisp مخفف Lost in stupid parentheses هست)‌، مطمئنا باید راهی برای حل این مشکل داشته باشد.
برای این کار خطوط زیر را داخل ‎.emacs وارد می‌کنیم:&lt;/p&gt;


&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;electric-pair-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;show-paren-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب با خط اول‌، به ایمکس می‌گوییم‌، هر وقت ما پرانتزی (که شامل تمام علاماتی است که در بالا اشاره کردیم) باز کردیم‌، خودت به صورت خودکار‌، کاراکتر بستن آن را وارد کن. همین‌طور در خط دوم مجبورش می‌کنیم وقتی روی پرانتزی هستیم‌، اگر جفتی برایش وجود دارد‌، آن را برایمان نمایش دهد (هر دو طرف پرانتز سبز می‌شود معمولا‌. با توجه به تنظیمات پوستهٔ ایمکس)‌. اگر نه‌، سمتی که رویش ایستاده‌ایم را قرمز کن تا بفهمیم تنهاست ;-)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dl.dropboxusercontent.com/u/25017694/Blog-photos/emacsparenmatch.png"&gt;&lt;img alt="نمونه‌ای از نمایش جفت پرانتز در ایمکس" src="https://dl.dropboxusercontent.com/u/25017694/Blog-photos/emacsparenmatch.png" width="328" height="42"&gt;&lt;/a&gt; نمونه‌ای از نمایش جفت پرانتز در ایمکس&lt;/p&gt;
&lt;p&gt;بخش اول کار که معلوم است. ولی این بخش دوم قابلیت‌های جالب دیگری هم دارد. مثلا می‌توان با(setq show-paren-delay 0) میزان زمانی که طول می‌کشد تا جفت کاراکتر پرانتزمان را نمایش دهد را تعیین کنیم. از قرار به طور پیش‌فرض مقداری Delay تعیین شده که ما با این دستور می‌توانیم صفرش کنیم. من این کار را نکردم چون به نظرم سر موقع نمایش داده می‌شوند.&lt;/p&gt;
&lt;p&gt;همین‌طور می‌توان با(setq show-paren-style 'MODE) تعیین کرد که نمایش هر جفت پرانتز چطور باشد. که برای این کار باید عبارت MODE را با یکی از سه گزینهٔ زیر جایگزین کنیم:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;parenthesis&lt;/strong&gt; که مد پیش‌فرض است و فقط پرانتز‌های دو طرف را نمایش می‌دهد.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;expression&lt;/strong&gt; که علاوه بر پرانتز‌ها‌، متن درونشان هم برجسته می‌شود.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;mixed&lt;/strong&gt; که اگر پرانتز‌ها بالانس باشند مثل مد parenthesis عمل می‌کند و گرنه مثل expression.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;به همین سادگی می‌توانید آن‌طور که می‌خواهید این رفتار ایمکس را هم کنترل کنید.&lt;/p&gt;
&lt;p&gt;من این آموزش را نمی‌دانم از کجای اینترنت یاد گرفتم. ولی این &lt;a title="Emacsfu" href="http://emacs-fu.blogspot.de/2009/01/balancing-your-parentheses.html" target="_blank"&gt;وبلاگ&lt;/a&gt; هم به آن اشاره کرده که وبلاگ عالی‌ای هم هست. پیشنهاد می‌کنم از دستش ندهید. خیلی خیلی تکنیک‌های جالبی با آن یاد خواهید گرفت.&lt;/p&gt;</description><category>Emacs</category><category>Emacs-fu</category><category>lisp</category><category>Parenthesis</category><category>ایمکس</category><category>برنامه نویسی</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920127yn-ymkhs-dwst-dshtny-blns-khrdn-prn.html</guid><pubDate>Tue, 16 Apr 2013 12:24:21 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (Backup‌ها و Autosave‌ها)</title><link>http://shahinism.github.io/posts/blog13920125yn-ymkhs-dwst-dshtny-backuph-w-autosaveh.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از ویژگی‌های خوب‌، به درد بخور ولی سرسام آوری که در اکثر ویرایشگرهای لینوکسی با پدر و مادر دیده‌ایم‌، قابلیت پشتیبان گیریست‌! قابلیتی که هر چند می‌دانیم که خیلی به آن نیاز پیدا خواهیم کرد‌، عموما از ریختش خوشمان نمی‌آید. عموما شیوهٔ کار این پشتیبان‌گیر‌ها به این صورت است که در همان جایی که فایل اصلی وجود دارد‌، یک فایل پشتیبان به صورت خودکار ایجاد می‌کنند و هیچ وقت هم آن را پاک نمی‌کنند‌! خوب برای آدم‌های وسواسی‌ای مثل من‌، این کمی اذیت کننده است که آن‌ها را در کنار فایل‌های اصلی‌ام ببینم‌!
ساده‌ترین راه‌کار‌، خاموش کردنش است‌! ولی خاموش کردن هم خطرناک است. قربانش بروم نیست کلا همه چیز‌مان قابل اطمینان است‌، مطمئن باشید سر حساس‌ترین ادیت‌تان‌، برق سیستم قطع می‌شود (این خط‌| ، این نشان D:).&lt;/p&gt;
&lt;p&gt;این است که برای ایمکس یک جای مخصوص درست می‌کنیم که این پشتیبان‌ها را در آن جا بریزد. این‌طوری نه ساختار سیستم فایل‌مان را شلخته می‌کنیم‌، و نه از نعمت وجود پشتیبان‌ها بی‌بهره می‌شویم.&lt;/p&gt;


&lt;div class="code"&gt;&lt;pre&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;custom-set-variables&lt;/span&gt;
 &lt;span class="c1"&gt;;; custom-set-variables was added by Custom.&lt;/span&gt;
 &lt;span class="c1"&gt;;; If you edit it by hand, you could mess it up, so be careful.&lt;/span&gt;
 &lt;span class="c1"&gt;;; Your init file should contain only one such instance.&lt;/span&gt;
 &lt;span class="c1"&gt;;; If there is more than one, they won't work right.&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;auto-save-file-name-transforms&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;".*"&lt;/span&gt; &lt;span class="s"&gt;"~/.emacs.d/autosaves/\\1"&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;backup-directory-alist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;".*"&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"~/.emacs.d/backups/"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب‌، تمام نکتهٔ اصلی ماجرا این‌جاست که ما با تابع custom-set-variables سر و کار داریم. این تابع را در واقع قرار نیست که ما صدا بزنیم (ولی این یک‌بار اشکال ندارد‌). حقیقتش نیاز هم نیست‌، چون این تنظیمات را می‌توان با خود ایمکس انجام داد. کافیست از منوی ایمکس‌، Options و Customize Emacs را انتخاب کنیم‌، بخش مورد نظر را پیدا و انگولکش کنیم و سپس Apply &amp;amp; Save و خود ایمکس همچین چیزی را برای‌مان اضافه می‌کند! ولی خوب من حال سر و کله زدن با این منو‌ها را ندارم. پس باید بروم و همین متغیر‌ها که می‌بینید را مستقیما تغییر دهم. خوب آن وقت یک کمی کثیف‌کاری می‌شود. چرا؟ چون آن وقت این Customize ایمکس تنظیمات ما را نمی‌خواند و ممکن است برای یک همچین تنظیم پایه‌ای‌، مشکل بزاید برای‌مان.&lt;/p&gt;
&lt;p&gt;باauto-save-file-name-transforms ما در واقع شیوهٔ نام‌گذاری Autosave‌ها را با یک Regex تغییر می‌دهیم. خود ایمکس‌، آن بخش آدرس دایرکتوری را‌، به مسیر جدید فایل تبدیل می‌کند و فایل‌ها را در آن‌جا ذخیره می‌کند. Autosave‌ها به صورت #FileName#  و به صورت خودکار ذخیره می‌شوند و شامل آخرین تغییرات یک بافر هستند.&lt;/p&gt;
&lt;p&gt;دقیقا همین کار را هم با متغیرbackup-directory-alist انجام می‌دهیم که وظیفهٔ تغییر نام backup‌ها را بر عهده دارد. این پشتیبان‌ها در واقع آخرین وضعیت Save شدهٔ یک بافر را ارائه می‌دهند و به صورت FileName~ ‎ نام‌گذاری می‌شوند.&lt;/p&gt;
&lt;p&gt;حالا نکته این‌جاست که احتمالا بعد از Restart ایمکس‌، با این اخطار روبرو می‌شوید که دایرکتوری Autosaves که آدرس داده‌اید وجود ندارد. یک کار این است که آن را به صورت دستی ایجادش کنید. فقط یک بار لازم است. و بعد ایمکس‌تان را اجرا کنید. یک کار دیگر هم می‌توان با دستور لیسپ زیر‌، چک کرد که اگر دایرکتوری وجود نداشت‌، خود ایمکس ایجادش کند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;make-directory&lt;/span&gt; &lt;span class="s"&gt;"~/.emacs.d/autosaves/"&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;من این تنظیمات را از &lt;a href="http://snarfed.org/gnu_emacs_backup_files"&gt;این پست&lt;/a&gt; یاد گرفتم. وبلاگ قدیمی‌ایست‌، و چیز‌های خوبی در مورد ایمکس می‌توان ازش یاد گرفت.&lt;/p&gt;</description><category>Autosave</category><category>Backup</category><category>Emacs</category><category>ایمکس</category><category>حل مشکل</category><category>دوره</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920125yn-ymkhs-dwst-dshtny-backuph-w-autosaveh.html</guid><pubDate>Sun, 14 Apr 2013 09:13:41 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (ido-mode)</title><link>http://shahinism.github.io/posts/blog13920122yn-ymkhs-dwst-dshtny-ido-mode.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از قابلیت‌های جالب تکمیل خودکاری که در ابزار‌های امروزی می‌بینیم‌، تکنیک fuzzy matching است که کار تکمیل خودکار را فوق‌العاده آسان می‌کند. نمونه‌ای از این تکمیل خودکار را در آدرس‌بار Firefox دیده‌ایم. جایی که شما می‌توانید آدرس را از هر کجا یادتان است تکمیل کنید و اجباری به تایپ اول آدرس ندارید. امروز قصد داریم همچین قابلیتی را در ایمکس معرفی کنیم. این قابلیت می‌تواند در تکمیل نام buffer‌، فایل‌ها و دستورات ایمکسی‌، خیلی خیلی کمک کننده باشد. ابزاری که در ایمکس این امکان را فراهم می‌آورد ido نام دارد.
ترجیح می‌دهم قابلیت‌های این ابزار را به لغت بیان نکنم‌، چون نمی‌توانم. این است که ویدئویی در اینترنت پیدا کردم که می‌تواند لپ کلام را در دو دقیقه به شما نشان دهد‌، بدون این که نیازی به زیاده گویی‌های من باشد. این ویدئو را می‌توانید از&lt;a title="لینک ویدئو در یوتوب" href="http://youtu.be/lsgPNVIMkIE" target="_blank"&gt; این‌جا &lt;/a&gt;در یوتوب ببینید (مگر چه عیبی دارد گاهی مرا هم جو آزاد نشینی بگیرد و فکر کنم همه اینترنت آزاد دارند؟). اگر هم سخت‌تان است این ویدئو را از پشت خط شکن ببینید‌، برای‌تان روی &lt;a title="دانلود ویدئو از Mega" href="https://mega.co.nz/#!A0dymZqY!RInwER-nRLUijWh3tIxcOFD3-CBcg-CgHN0ZzO-TkQI" target="_blank"&gt;Mega&lt;/a&gt; آپلود کرده‌ام. حجم ویدئو ۵ مگ بیشتر نیست!&lt;/p&gt;
&lt;p&gt;حالا که ویدئو را دیدید کافیست با اضافه کردن کد زیر به ‎.emacs  آن را در ایمکس‌تان فعال کنید:&lt;/p&gt;


&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;ido-enable-flex-matching&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;ido-everywhere&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ido-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;پس از قرار دادن این کد‌، کلید‌های جستجوی فایل یا تعویض بافر‌، با دستورات همتای‌شان که از ido استفاده می‌کنند‌، جایگزین می‌شوند. این ابزار قابلیت‌های شخصی‌سازی بیشتری هم دارد. مثلا این که کدام پسوند‌ها را در اولیوت قرار دهد. من نیازی به این تنظیمات پیدا نکردم. اما اگر شما وسوسه به همچین تنظیمی شده‌اید می‌توانید به &lt;a title="idomode in mastering emacs" href="http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/" target="_blank"&gt;این پست&lt;/a&gt; mastring emacs رجوع کنید.&lt;/p&gt;
&lt;p&gt;گاها پیش می‌آید که در هنگام جستجوی فایلی (خصوصا در زمان ایجاد) این ابزار کمی دست و پا گیر می‌شود. برای فرار از این حالت کافیست دستور ٰC-f  را وارد کنید‌، تا به حالت معمول جستجوی فایل بازگردید.&lt;/p&gt;</description><category>Emacs</category><category>fuzzy matching</category><category>ido-mode</category><category>ایمکس</category><category>دوره</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920122yn-ymkhs-dwst-dshtny-ido-mode.html</guid><pubDate>Thu, 11 Apr 2013 11:47:19 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (ergoemacs-mode)</title><link>http://shahinism.github.io/posts/blog13920119yn-ymkhs-dwst-dshtny-ergoemacs-mode.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;قبلا هم گفتم‌، ایمکس در حالت عادی‌، قابل قبول است‌، ولی خیلی خیلی می‌تواند بهتر باشد. یکی از اولین عادت‌ها بعد از مهاجرت به ایمکس‌، کلید‌های میانبر پر استفاده‌اش است. در &lt;a title="این ایمکس دوست داشتنی (تعریف کلید میانبر)" href="http://shahinism.com/blog/1392/01/17/%d8%a7%db%8c%d9%86-%d8%a7%db%8c%d9%85%da%a9%d8%b3-%d8%af%d9%88%d8%b3%d8%aa-%d8%af%d8%a7%d8%b4%d8%aa%d9%86%db%8c-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%a9%d9%84%db%8c%d8%af-%d9%85%db%8c%d8%a7%d9%86%d8%a8/"&gt;پست قبلی&lt;/a&gt; در موزد کلید‌های میانبر ایمکس حرف زدیم. اما بدیهی است که تعریف کلید میانبر برای دستوراتی این چنین پر استفاده که هم با دیگر کلید‌های میانبر تعریف شده در محیط‌های مختلف تداخل نداشته باشد و هم یاد آوری‌شان آسان باشد‌، کار آسانی نیست. خصوصا این که ایمکس پیشنهاد می‌کند کلید میانبر‌تان با C-c شروع شود و با یک کاراکتر تکی ادامه یابد. تعارف که نداریم‌، خیلی محدود است. ضمن این که ما کلید‌های آن‌چنان پر استفادهٔ زیادی نداریم که بخواهیم به همچین آکورد‌های سنگینی محدود شویم.
کلید‌های پر استفادهٔ عمومی شامل انتقال نشانگر‌، Yanking، پاک کردن کاراکتر‌ها‌، مدیریت پنجره‌ها و جستجو‌هاست. این‌ها دستوراتی هستند که در اکثر ویرایش‌ها به آن‌ها نیاز داریم. ضمن این که بسیاری از این دستورات در برنامه‌های دیگر هم شامل کلید‌های میانبری هستند که تقریبا به صورت یک استاندارد در آمده‌اند. نمونه‌ای از این دستورات‌، کپی و پیست است. شما در اکثر محیط‌ها‌، از جمله مرورگر‌تان‌، با C-c کپی می‌کنید و با C-v پیست. حالا باید در ایمکس آن را با C-w و C-y جایگزین کنید. خوب یک کمی ترک عادت نیاز دارد‌، ولی تلاش سختی است. البته ایمکس خودش یک CUA-mode دارد که می‌توان به راحتی اضافه کردن(cua-mode 1) در ‎.emacs آن را فعال کنید. ولی در مورد باز کردن یک فایل جدید چطور؟ در اکثر برنامه‌ها این کار با C-o امکان‌پذیر است‌، در حالی که در ایمکس باید این کار را با C-x C-f انجام دهید! سخت است دیگر!&lt;/p&gt;
&lt;p&gt;سخت‌تر از همه این که به QWERTY وابسته‌اند. آن وقت است که اگر به &lt;a title="چینش (لایوت) Workman و داستان مهاجرتم" href="http://shahinism.com/blog/1392/01/14/%da%86%db%8c%d9%86%d8%b4-%d9%84%d8%a7%db%8c%d9%88%d8%aa-workman-%d9%88-%d8%af%d8%a7%d8%b3%d8%aa%d8%a7%d9%86-%d9%85%d9%87%d8%a7%d8%ac%d8%b1%d8%aa%d9%85/"&gt;Workman&lt;/a&gt; یا Colemak سوئیچ کنید‌، انگار به کیبورد‌تان دینامیت بسته‌اید! از آن بد‌تر این که با کاراکتر‌های فارسی کار نمی‌کنند.&lt;/p&gt;
&lt;p&gt;این مقدمه را گفتم که بگویم‌، عده‌ای جمع شده‌اند و مدی ساخته‌اند به اسم &lt;a title="Ergoemacs official page" href="http://ergoemacs.org/index.html" target="_blank"&gt;ergoemacs-mode&lt;/a&gt; که هدفش حل مشکلات ذکر شده در مقدمهٔ بالاست. نتیجه‌، از عکس زیر معلوم است:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="ergoemacs-mode رو چینش workman" src="http://dl.dropbox.com/u/25017694/Blog-photos/ergoworkman.png" width="586" height="218"&gt; ergoemacs-mode رو چینش workman&lt;/p&gt;
&lt;p&gt;این عکس طبق چینش Workman تولید شده‌،‌ ولی جای دکمه‌ها در لایوت‌های دیگر‌، از جمله QWERTY و Colemak هم یک‌سان است. از نکات مهم مد نظر قرار داده شده در هنگام طراحی این Key binding‌ها می‌توان به موارد زیر اشاره کرد:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;  کلید‌های Home row بهترین‌ها هستند.&lt;/li&gt;
    &lt;li&gt;Alt خیلی بهتر از Ctrl است. Alt را باید با شصت گرفت که زورش خیلی بیشتر از انگشت کوچیکهٔ مخصوص Ctrl است!&lt;/li&gt;
    &lt;li&gt;به جای سرحرف اول دستورات‌، بهتر است به مکان دستورات هم خوانواده توجه شود. مثلا به مکان کلید‌های جاب‌جایی نگاه کنید. همین‌طور کلید‌های پاک کردن را ببینید!&lt;/li&gt;
    &lt;li&gt;و چند‌تای دیگر که آن‌قدرها هم مهم نیستند.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;نکته این‌جاست که نتیجهٔ کار خیلی عالی شده. آن‌قدر عالی که طی رد و بدل چند ایمیل‌ در&lt;a title="ergoemacs mailing list" href="https://groups.google.com/group/ergoemacs" target="_blank"&gt; لیست ایمیل&lt;/a&gt; پروژه‌، زبان فارسی را هم به این مجموعهٔ کامل اضافه کردیم که نتیجه‌اش را در زیر می‌بینید:&lt;/p&gt;
&lt;p&gt;&lt;img class=" " alt="ergoemacs-mode روی چینتش استاندارد فارسی" src="http://dl.dropbox.com/u/25017694/Blog-photos/ergofa.png" width="586" height="218"&gt; ergoemacs-mode روی چینتش استاندارد فارسی&lt;/p&gt;
&lt;p&gt;کیبورد استاندارد فارسی است که به صورت پیش‌فرض در لینوکس وجود دارد‌، ولی ویندوزی‌ها باید برنامهٔ متناسبش را پیدا و نصب کنند تا پشتیبانی شود D:&lt;/p&gt;
&lt;h5&gt;نصب&lt;/h5&gt;

&lt;p&gt;طبق&lt;a title="این ایمکس دوست داشتنی (مدیر بسته)" href="http://shahinism.com/blog/1392/01/08/%d8%a7%db%8c%d9%86-%d8%a7%db%8c%d9%85%da%a9%d8%b3-%d8%af%d9%88%d8%b3%d8%aa-%d8%af%d8%a7%d8%b4%d8%aa%d9%86%db%8c-%d9%85%d8%af%db%8c%d8%b1-%d8%a8%d8%b3%d8%aa%d9%87/" target="_blank"&gt; آن‌چه که در گذشته گفتم‌&lt;/a&gt;، ergoemacs-mode را از مدیر‌بسته‌های ایمکس نصب کنید و سپس تنظیمات زیر را به فایل ‎.emacs‌‌تان اضافه کنید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;setenv&lt;/span&gt; &lt;span class="s"&gt;"ERGOEMACS_KEYBOARD_LAYOUT"&lt;/span&gt; &lt;span class="s"&gt;"workman"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'ergoemacs-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ergoemacs-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در خط اول‌، اسم لایوت پیش‌فرض را اضافه می‌کنیم‌، و در خط‌های بعد ergoemacs-mode را فراخوانی و فعال می‌کنیم. بعد از یک Restart‌، با کلید‌های جدید روبرو می‌شوید D:&lt;/p&gt;
&lt;h5&gt;گرفتن کمک&lt;/h5&gt;

&lt;p&gt;خوب یک تغییر عادت است و احتمالا اول کار خیلی پیش می‌آید که دستورات قبلی‌تان را بزنید و نتیجه نگیرید! برای پیدا کردن کلید‌های جدید‌، کافیست C-h o را وارد کرده و سپس کلید قبلی‌تان را وارد کنید. این تابع بعد از بررسی کلید‌های قدیمی‌، هم‌تایان جدید‌شان را معرفی می‌کند.&lt;/p&gt;
&lt;h5&gt;دیگر سطوح&lt;/h5&gt;

&lt;p&gt;یکی از ویژگی‌های ergoemacs-mode‌، قابلیت تعیین سطحش است. سطوح مختلفی که با توجه به سلیقه‌های مختلف کاربران طراحی شده است. مثلا سطح guru کلید‌های فلش را برای تغییر موقعیت نشانگر می‌بندد و بعد از هر بار زدنشان‌، کلید‌های متناسب با سلیقهٔ ایمکس را نشان‌تان می‌دهد. و یا سطح master (فکر کنم) کلید backspace را خاموش می‌کند تا مجبور شوید از روش‌های پاک کردن کاراکتر ایمکس بهره بگیرید که سریع‌تر است. برای تنظیم این ویژگی‌ها کافیست سطح مورد نظر را انتخاب کنید (بعد از نصب ergoemacs از منو انتخابش کنید و ergoemacs variants را ببینید) و در دستور(setq ergoemacs-variant "SATH") آن را در جای SATH قرار دهید.&lt;/p&gt;
&lt;h5&gt;ergoemacs-extras&lt;/h5&gt;

&lt;p&gt;با فراخوانی این تابع در ایمکس‌، ergoemacs اقدام به ایجاد فایل‌های راهنمای کیبورد ergo در سطوح مختلف به فرمت svg می‌کند که می‌تواند خیلی کمک کننده باشد (عکس‌های موجود در این نوشته هم با همین روش ایجاد شده‌اند.). همین‌طور فایل‌هایی برای تطابق این کلید‌ها با محیط‌های دیگر از جمله bash ایجاد می‌شود که می‌توانند در ایجاد یک‌پارچگی برای محیط کار عالی باشند. (هنوز امتحانش نکرده‌ام ولی نتیجه‌اش را به زودی اطلاع می‌دهم.)&lt;/p&gt;
&lt;p&gt;این فایل‌ها در مسیر ‎~‎‍/.emacs/ergoemacs-extras در دسترسند که با توجه به سطوح مختلف پوشه‌بندی شده‌اند.&lt;/p&gt;
&lt;h5&gt;نتیجه&lt;/h5&gt;

&lt;p&gt;به نظر من نتیجهٔ کار فوق‌العاده قابل قبول است. راحتی استفاده از کلید‌های پر کاربرد و راحت‌تر از آن معکوس کردن اکثر دستورات با Shift فوق‌العاده کمک می‌کند. به طور پیش‌فرض برای خیلی کار‌ها مجبوریم در ایمکس از ارسال آرگومان به دستورات برای تغییر حالت‌شان استفاده کنیم که در Ergoemacs این کار عموما با Shift انجام می‌گیرد. مثلا C-f جستجوی رو به جلو انجام می‌دهد و C-S-f جستجوی رو به عقب!&lt;/p&gt;
&lt;p&gt;از طرفی کلید‌های C-a که در تمام محیط‌های دیگر برای انتخاب کل محتویات صفحه است و یا کلید‌های C-z, C-x, C-c, C-v, C-f, C-o, C-s, C-s-s , و خیلی کلید‌های دیگر که در محیط‌های دیگر از آن‌ها بهره می‌گیریم‌، به راحتی در این‌جا نیز جواب می‌دهند و کار ویرایش را فوق‌العاده راحت‌تر کرده‌اند. حتی با Ergoemacs دستور جدیدی اضافه شده که می‌توان با C-n یک صفحهٔ جدید ساخت‌، بدون این که نیاز به افزودن نامی به آن داشته باشیم.&lt;/p&gt;
&lt;p&gt;یک قابلیت جالب دیگر‌، استفاده از کلید‌های yanking‌ (کپی پیست در ایمکس) بدون Region (متن انتخاب شده) است. در این صورت‌، دستورات کل خط یا صفحه را تحت تاثیر قرار می‌دهند.&lt;/p&gt;
&lt;p&gt;در آینده بیشتر هم در مورد ergoemacs حرف می‌زنیم.&lt;/p&gt;</description><category>CUA-mode</category><category>Emacs</category><category>ergoemacs-mode</category><category>ایمکس</category><category>برنامه نویسی</category><category>دوره</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920119yn-ymkhs-dwst-dshtny-ergoemacs-mode.html</guid><pubDate>Mon, 08 Apr 2013 19:29:09 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (تعریف کلید میانبر)</title><link>http://shahinism.github.io/posts/blog13920117yn-ymkhs-dwst-dshtny-tryf-khlyd-mynb.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;یکی از حیاتی‌ترین چیز‌هایی که در ایمکس لازم است بدانیم‌، چگونگی تعریف کلید میانبر برای توابع مختلف است. همان‌طور که احتمالا تا این‌جای قضیه متوجه شده‌اید‌، همهٔ کار‌هایی که در ایمکس انجام می‌دهیم‌، توابعی است که چه همراه خود ایمکس وجود دارند و چه با استفاده از بسته‌هایی که نصب می‌کنیم به آن اضافه می‌شوند. این توابع را می‌توان به صورت M-x FUNCTION_NAME RET  صدا کرد. اما در هنگام کار در ایمکس‌، سخت است که برای هر دستوری‌، مثل رفتن به خط بعد/قبل بیاییم و به این روش عمل کنیم. این است که برای هر تابع پر استفاده‌ای که داریم‌، یک کلید میانبر تعریف می‌کنیم.
لازم به ذکر است که برای اثبات بحث بالا‌، می‌توانید از تابع describe-key  همراه ایمکس استفاده کنید. کار این تابع این است که به شما بگوید که کلید میانبر مد نظر‌تان‌، چه تابعی را صدا می‌کند. برای نمونه‌، این دستور را وارد کنید M-x describe-key RET C-x C-f . همان‌طور که می‌بینید تابع مربوطه در یک پنجرهٔ جدید به نمایش در می‌آید. حالا برویم سر بحث تعریف کلید میانبر:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h5&gt;کلید میانبر سراسری&lt;/h5&gt;
&lt;p&gt;منظور از کلید میانبر سراسری‌، کلید‌هایی است که در همهٔ Major-mode‌ها (مد‌های اصلی) به راحتی عمل می‌کنند. برای نمونه C-n  یک کلید میانبر سراسری است. در تمامی مد‌ها اعم از ویرایش متن معمولی و یا کد برنامهٔ C‌، این کلید میانبر‌، نشانگر را به خط بعد منتقل می‌کند. برای تعریف چنین کلید میانبری می‌توانیم از یکی از دو روش زیر بهره ببریم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"KEY"&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;define-key&lt;/span&gt; &lt;span class="nv"&gt;global-map&lt;/span&gt; &lt;span class="s"&gt;"KEY"&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;برای کسب اطلاعات بیشتر در مورد هر کدام از این توابع می‌توانید از تابع describe-function  همراه ایمکس کمک بگیرید. برای مثال M-x describe-function RET global-set-key RET . یا از کلید میانبرش استفاده کنید C-h f . همین‌طور اگر نشان‌گرتان روی یک تابع ایمکس باشد‌، خود تابع می‌تواند آن را حدس بزند.&lt;/p&gt;
&lt;p&gt;تابع اول که تقریبا سر راست است. global-set-key  همان‌طور که از نامش پیداست‌، یک کلید سراسری به اسم KEY که می‌تواند ترکیبی به صورت&lt;span class="lang:default decode:true  crayon-inline"&gt;"‎\C-c f" باشد‌، برای تابع FUNCTION_NAME تعریف می‌کند. همان‌طور که احتمالا متوجه شده‌اید‌، من برای نشان‌دادن Ctrl  در کلید میانبرم از ‎‎\C  استفاده کردم. همین‌طور برای Alt  باید از ‎\M  استفاده کنم. تعریف کلید به این صورت شاید کمی خسته کننده و نا خوانا به نظر بیاید. برای راحتی بیشتر می‌توان از تابع kbd  استفاده کرد. برای نمونه طبق مثالمان‌، همچین چیزی خواهیم داشت:&lt;/span&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kbd&lt;/span&gt; &lt;span class="s"&gt;"C-c f"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'FUNCTION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خود تابع kbd  می‌داند که چطور این کلید را ترجمه کند. برای کسب اطلاعات بیشتر در این مورد می‌توانید باز هم از C-h f  یا تابع متناظرش استفاده کنید. باور کنید که اطلاعات خیلی بهتری به دست می‌آورید ;-)&lt;/p&gt;
&lt;p&gt;در تابع دوم ما کار مشابهی را انجام دادیم‌، با این تفاوت که تابع define-key  نیاز به این دارد که بداند کلید میانبر را در کدام محیط اجرا کند. به عبارت دیگر‌، کلید میانبر در کدام Mode در دسترس باشد. از آن‌جایی که قصد ما تعریف کلید میانبر سراسری است به محیط global-map  اشاره می‌کنیم که به define-key  می‌فهماند کلید باید در همه جا در دسترس باشد.&lt;/p&gt;
&lt;h5&gt;کلید میابر محدود به مد خاص&lt;/h5&gt;

&lt;p&gt;با این توضیح آخر بخش قبل‌، فکر کنم موضوع کاملا روشن شده باشد. کافیست برای تعریف میانبر برای یک مد خاص‌، محیط مربوط به آن مد را به define-key  نشان دهیم. برای مثال اگر می‌خواهیم که کلید میانبر تنها در محیط متنی در دسترس باشد‌، به جای global-map  از text-mode-map  استفاده می‌کنیم. محیط‌های مربوط به هر مد اصلی‌، عموما به صورت mode-name-map  شناسایی می‌شوند و در هنگام تعریف کلید‌، کافیست نام map مد مورد نظر‌تان را کشف کنید ;-)&lt;/p&gt;</description><category>define-key</category><category>Emacs</category><category>global-map</category><category>global-set-key</category><category>text-mode-map</category><category>ایمکس</category><category>برنامه نویسی</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920117yn-ymkhs-dwst-dshtny-tryf-khlyd-mynb.html</guid><pubDate>Sat, 06 Apr 2013 09:06:38 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (تنظیمات ظاهری)</title><link>http://shahinism.github.io/posts/blog13920112yn-ymkhs-dwst-dshtny-tnzymt-zhry.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;بعد از تنظیمات مربوط به مدیر بسته‌، نوبت به تنظیمات ظاهر اصلی ایمکس می‌رسد. ظاهر اولیهٔ رابط گرافیکی‌، فوق‌العاده بی‌روح و سفید است که برای کار‌های طولانی مدت (شامل خیره شدن زیاد به صفحه) اصلا مناسب نیست. همینطور شامل اجزایی نظیر Scroll-bar و یا Toolbar است که با وجود کلید‌های میانبر مناسب که مستقیما از فلسفهٔ ایمکس پیروی می‌کنند‌، بودنشان جز جا‌گیر بودن‌، فایدهٔ دیگری ندارد. از طرفی‌، با استفاده از توابع همراه ایمکس می‌توان ظاهر فوق‌العاده مدرن‌تری نسبت به ظاهر اولیه فراهم آورد که در این پست قصد داریم در مورد‌شان بحث کنیم. تنها دو نکته باقی می‌ماند که لازم می‌دانم این‌جا ذکر کنم:
&lt;/p&gt;&lt;ol&gt;&lt;li&gt;  این پست احتمالا آخرین پست (فعلا) این‌چنین بزرگ و ترکیبی از این سری است. همان‌طور که در مقدمه گفتم‌، قرار است در این سری قدم به قدم با ایمکس آشنا شویم و در هر پست (هر چند کوتاه) یک ویژگی را به طور کامل بررسی کنیم. اما از آن‌جا که لازم است برای شروع کار‌، کمی از ایمکس اولیه دور شویم‌، لازم دانستم که چند پست ترکیبی نیز داشته باشیم.&lt;/li&gt;
    &lt;li&gt;دستکاری ظاهری ایمکس در همین پست پایان نمی‌یابد. در آینده ویژگی‌های جالب‌تری هم به این رابط کاربری می‌افزاییم. این تنها یک شروع است.&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;پاک کردن اجزای اضافه&lt;/h5&gt;
&lt;p&gt;برای پاک کردن Scroll-bar و Toolbar تنها کافیست توابع‌شان را با یک آرگومان منفی صدا بزنیم. به صورت زیر:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tool-bar-mode&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;scroll-bar-mode&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همینطور می‌توان با اختصاص دادن آرگومان منفی به تابعmenu-bar-mode منوی بالای فریم ایمکس را هم حذف کرد. ولی از آن‌جایی که تازه کاریم و هنوز خیلی چیز‌ها هستند که می‌توان با گردش در منو‌ها یاد گرفت‌، از این کار صرف نظر می‌کنیم. خوبی این منوبار این است که عموما‌، بسته‌های بزرگ ایمکس‌، یک منوی اختصاصی برای خودشان آماده می‌کنند و این خیلی می‌تواند در اوایل آشنایی با یک بسته کمک کننده باشد.&lt;/p&gt;
&lt;h5&gt;رنگ‌بندی پنجره‌ها&lt;/h5&gt;

&lt;p&gt;یکی از ساده‌ترین راه‌ها برای تعیین رنگ‌بندی پنجرهٔ ایمکس‌، استفاده از قالب‌های آماده است. خوشبختانه در کنار قالب‌های ساده و ساخته شده از روی علاقهٔ شخصی‌، قالب‌هایی نظیر &lt;a title="Solarized official" href="http://ethanschoonover.com/solarized" target="_blank"&gt;Solarized&lt;/a&gt; و &lt;a title="Zenburn official" href="http://slinky.imukuppi.org/zenburnpage/" target="_blank"&gt;Zenburn&lt;/a&gt; که اهداف خاصی را از رنگ‌بندی‌شان دنبال می‌کنند نیز وجود دارند. برای نصب‌شان تنها کافیست دستور متناسب با نام بسته‌شان را به صورت زیر وارد کنید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;RET&lt;/span&gt; &lt;span class="n"&gt;solarized&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;theme&lt;/span&gt; &lt;span class="n"&gt;RET&lt;/span&gt;
&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;RET&lt;/span&gt; &lt;span class="n"&gt;zenburn&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;theme&lt;/span&gt; &lt;span class="n"&gt;RET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;جدای از این دستورات با جستجو در package-list-packages می‌توانید هم به این پوسته‌ها و هم به خیل عظیم پوسته‌های آمادهٔ ایمکس دسترسی داشته باشید که تست کردن‌شان خالی از لطف نیست. پس از نصب پوستهٔ مورد نظر‌، کافیست با استفاده از دستور M-x load-theme THEME_NAME آن را فعال کنید. البته از آن‌جایی که دل‌تان نمی‌خواهد بعد از هر بار لود شدن ایمکس‌، مجبور به اجرای این دستور باشید‌، کافیست‌ دستور زیر را در ‎.emacs‌تان قرار دهید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;load-theme&lt;/span&gt; &lt;span class="ss"&gt;'zenburn&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;توجه داشته باشید که پوستهٔ Solarized دارای دو حالت تیره و روشن است‌، که شما هم باید در هنگام وارد کردن نامش‌، به این نکته توجه کنید.&lt;/p&gt;
&lt;h5&gt;رنگ‌بندی با استفاده از ‎.Xresources&lt;/h5&gt;

&lt;p&gt;روش دیگر‌ تعیین رنگ‌بندی پنجرهٔ ایمکس‌، با استفاده از فایل ‎.Xresources سیستم‌هایی است که از X برای محیط گرافیکی‌شان استفاده می‌کنند. روش کار با این فایل را در &lt;a title="عشق بازی با ترمینال لینوکس‌ (urxvt, رنگ‌آمیزی و کانفیگش)" href="http://shahinism.com/blog/1391/08/04/%d8%b9%d8%b4%d9%82-%d8%a8%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7-%d8%aa%d8%b1%d9%85%db%8c%d9%86%d8%a7%d9%84-%d9%84%db%8c%d9%86%d9%88%da%a9%d8%b3%e2%80%8c-urxvt-%d8%b1%d9%86%da%af%e2%80%8c%d8%a2%d9%85%db%8c/" target="_blank"&gt;این پست &lt;/a&gt;توضیح دادم و همینطور ابزار &lt;a title="4bit" href="http://ciembor.github.com/4bit/" target="_blank"&gt;4bit&lt;/a&gt; را برای ایجاد رنگ‌های متناسب با هم معرفی کردم. من خودم فعلا از این روش استفاده می‌کنم که دو دلیل عمده دارد:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;  رنگ‌بندی برنامه‌هایی که از این سیستم استفاده می‌کنند یک پارچه می‌شوند. هم اکنون پوستهٔ استفاده شده برای ترمینال urxvt و ایمکس‌ام کاملا شبیه به هم است که خیلی خوب است.&lt;/li&gt;
    &lt;li&gt;پوستهٔ متناسب با سلیقه‌ام را در پوسته‌های آمادهٔ ایمکس پیدا نکردم. Zenburn عالی بود‌، ولی رنگ‌هایش چون چشم‌هایم را خسته نمی‌کردند‌، خودم خسته می‌شدم D: و Solarized هم درخشندگی لازم را برای جلب توجهم نداشت. من عادت به نگاه کردن سر سری نوشته‌ها قبل از خواندن‌شان دارم و برجسته بودن (درخشندگی) رنگ‌های استفاده شده در متن می‌تواند به پیدا کردن نکات جالب توجه کمکم کند.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;پوستهٔ ‎.Xresources‌ای که من استفاده می‌کنم را می‌توانید در&lt;a title="My .Xresources configuration on gist" href="https://gist.github.com/shahinism/5283609" target="_blank"&gt; این gist&lt;/a&gt; پیدا کنید.&lt;/p&gt;
&lt;h5&gt;تنظیم Font&lt;/h5&gt;

&lt;p&gt;بخش حیاتی قضیه است. حداقل برای من یکی‌، جدای از رنگ‌بندی برجسته‌، فونت و یک‌پارچگی‌اش در متن‌، اهمیت زیادی دارد. فونت پیش‌فرض ایمکس‌، اصلا دوست‌داشتنی نیست. اما تنها فونتی است که دیده‌ام در همه حالتی به راحتی جواب می‌دهد. ما هم که به جبر جغرافیا مجبور به استفاده از دو خط و زبانیم‌، باید چاره‌ای برای این قضیه پیدا کنیم. خوشبختانه‌، طی&lt;a title="Emacs font in stackexchange" href="http://stackoverflow.com/questions/11012627/emacs-font-for-western-and-other-like-rtl" target="_blank"&gt; یک پرسش و پاسخ&lt;/a&gt; بین دو دوست عزیزم (&lt;a title="وبلاگ افاضاتی" href="http://blog.efazati.org/" target="_blank"&gt;محمد افاضاتی&lt;/a&gt; و &lt;a title="یادداشت‌های بیت نیم‌سوز" href="http://cyberrabbits.net/" target="_blank"&gt;فرود&lt;/a&gt;)‌، فرود این مشکل را به شیوهٔ جالبی هک (حل) کرده که در ادامه به آن می‌پردازیم.&lt;/p&gt;
&lt;p&gt;من برای فونت پیش‌فرض از &lt;a title="Inconsolata on wikipedia" href="http://en.wikipedia.org/wiki/Inconsolata" target="_blank"&gt;Inconsolata&lt;/a&gt; استفاده می‌کنم که به نظرم برای کد نوشتن عالی است. همین‌طور برای کاراکتر‌های فارسی‌، از فونت tahoma استفاده می‌کنم. بله‌، بله می‌دانم که الان می‌گویید که &lt;a title="CSS Persian‌، یک ایدهٔ ساده ولی خیلی مفید" href="http://shahinism.com/blog/1391/06/10/css-persian%e2%80%8c%d8%8c-%db%8c%da%a9-%d8%a7%db%8c%d8%af%d9%87%d9%94-%d8%b3%d8%a7%d8%af%d9%87-%d9%88%d9%84%db%8c-%d8%ae%db%8c%d9%84%db%8c-%d9%85%d9%81%db%8c%d8%af/" target="_blank"&gt;قبلا&lt;/a&gt; گفته‌ای tahoma فیلان‌، tahoma بیسار! بله‌، هنوز هم می‌گویم. ولی tahoma تنها فونت فارسی‌ای است که در اندازهٔ کوچک (8pt) ‌این‌قدر خوب قابل خواندن است و از قرار با فونت‌های مناسب کد‌نویسی‌، هم‌نشینی خوبی دارد! (باشد که به غیرت آن‌ها که زور طراحی فونت مناسب را دارند بر بخورد و دست به کار شوند) برای اعمال فونت‌ها به صورت زیر عمل می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-default-font&lt;/span&gt; &lt;span class="s"&gt;"Inconsolata-10"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;



&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-fontset-font&lt;/span&gt;
   &lt;span class="s"&gt;"fontset-default"&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;decode-char&lt;/span&gt; &lt;span class="ss"&gt;'ucs&lt;/span&gt; &lt;span class="mh"&gt;#x0600&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;decode-char&lt;/span&gt; &lt;span class="ss"&gt;'ucs&lt;/span&gt; &lt;span class="mh"&gt;#x06ff&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; arabic&lt;/span&gt;
   &lt;span class="s"&gt;"Tahoma-8"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در خط اول‌، همان‌طور که معلوم است‌، فونت Inconsolata با سایز 10 را به عنوان فونت پیش‌فرض قرار دادیم. در ادامهٔ قضیه هم برای محدوده کاراکتر‌های عربی یونیکد‌، فونت Tahoma با سایز 8 را برای نمایش انتخاب کردیم. نتیجهٔ کار‌، فوق‌العاده قابل قبول است.&lt;/p&gt;
&lt;h5&gt;برجسته کردن خط حاضر و شماره خط‌ها&lt;/h5&gt;

&lt;p&gt;یکی از ویژگی‌های به درد بخور ویرایشگر‌های جدید‌، شمارهٔ خط‌هاست که در سمت چپ‌شان نوشته می‌شود. در حین توسعهٔ برنامه‌های پایتونی‌، مزیت این شماره‌ها کاملا مشهود است. این است که با اضافه کردن این دستور به ‎.emacs آن‌ها را به ایمکس‌مان اضافه می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-linum-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همینطور یکی دیگر از ویژگی‌هایی که خیلی به دردمان می‌خورد این است که خطی که در حال حاضر نشانگر روی آن قرار دارد‌، به صورت برجسته‌تر نمایش داده شود. این کار به چشم در هنگام جستجوی مکان فعلی نمایش‌گر‌، فوق‌العاده کمک می‌کند. برای این کار‌، تکه کد زیر را هم اضافه می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-hl-line-mode&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'hl-line&lt;/span&gt; &lt;span class="s"&gt;"#000"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در خط اول اعلام می‌کنیم که ویژگی برجسته کردن خط حاضر را فعال کن. بسیاری از قالب‌های آماده‌، مقداری برای رنگ پس زمینهٔ این خط تعیین می‌کنند. اما از آن‌جایی که من با استفاده از ‎.Xresources رنگ‌بندی قالب را تعیین کرده‌ام‌، باید این کار را به صورت دستی انجام دهم (خط دوم). نکته این‌جاست که ممکن است قالب‌تان رنگ خوبی برای‌تان نگذاشته باشد که باز هم می‌توانید با همین خط دوم ترتیبش را بدهید.&lt;/p&gt;</description><category>elisp</category><category>Emacs</category><category>Inconsolata</category><category>ایمکس</category><category>دوره</category><category>فونت</category><category>نرم افزار</category><guid>http://shahinism.github.io/posts/blog13920112yn-ymkhs-dwst-dshtny-tnzymt-zhry.html</guid><pubDate>Mon, 01 Apr 2013 11:00:26 GMT</pubDate></item><item><title>این ایمکس دوست داشتنی (مقدمه)</title><link>http://shahinism.github.io/posts/blog13920107yn-ymkhs-dwst-dshtny-mqdmh.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;ایمکس‌، ایمکس‌، ایمکس‌! اگر از دوست‌داران نهضت نرم‌افزار آزاد و شاید نهایتا متن‌باز باشید‌، احتمالا اسمش را شنیده‌اید (این در صورتی است که در حال حاضر از آن استفاده نمی‌کنید D:). خوب اگر شرط ذکر شده شامل حالتان نمی‌شود‌، تنها می‌توانم بگویم که شما هیچ تصوری نسبت به این که ایمکس‌، چه نوع نرم‌افزاری است‌، نمی‌توانید داشته باشید‌! نه‌، خوب به بند آخر جمله توجه کنید‌: &lt;strong&gt;&lt;span style="color: #ff0000;"&gt;نمـــی‌توانــــید‌، داشته باشید&lt;/span&gt;&lt;/strong&gt;! اگر اسم ایمکس به گوش‌تان خورده و هنوز پارهٔ تنتان نشده‌، احتمالا تنها با عبارت‌هایی مثل:«من از &lt;strong&gt;vim&lt;/strong&gt; استفاده می‌کنم.» یا مثلا «‌من با &lt;strong&gt;IDE‌ها&lt;/strong&gt; راحت‌تر برنامه توسعه می‌دم.» یا اصلا از این‌ها بدتر‌: «من اصلا برنامه‌نویس نیستم که بخوام بدونم ایمکس چیه» خودتان را گول زده‌اید!
گفتم «شما در صورتی که از ایمکس استفاده نمی‌کنید، نمی‌توانید تصوری از چیستی‌اش داشته باشید» چون عملا با هیچ نمونهٔ مشابهی از آن کار نکرده‌اید‌! شما حتی نمی‌دانید که این نرم‌افزار قادر است کدام نیاز‌تان را بر طرف کند. با خود‌تان رو راست باشید‌‌! قبول کنید که با ابزاری روبرو هستید که نمی‌دانید باید چه انتظاری از آن داشته باشید.&lt;/p&gt;
&lt;p&gt;&lt;a title="ایمکس در ویکی‌پدیا" href="http://wikipedia.org/wiki/Emacs" target="_blank"&gt;&lt;img alt="لوگوی Gnu Emacs." src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Emacs-logo.svg/270px-Emacs-logo.svg.png" width="270" height="217"&gt;&lt;/a&gt; لوگوی Gnu Emacs.&lt;/p&gt;
&lt;p&gt;خوب احتمالا به قدر کافی گیج شده‌اید‌! حتما با خود می‌گویید که چه نیازی به ابزاری دارم که نمی‌دانم به چه دردی می‌خورد‌؟ خوب کلید مساله همین‌جاست‌! اگر می‌خواهید با ایمکس آشنا شوید‌، باید از او انتظار داشته باشید که تمام کار‌های‌تان را برای‌تان انجام دهد‌! چطور؟ خوب چطوری‌اش را خیلی ساده واگذار می‌کنیم به پست‌هایی که قرار است طی یک سری پست سریالی در این وبلاگ منتشر کنم! اما قبل از شروع به انتشار‌شان باید به چند نکته اشاره کنم:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a title="صفحهٔ خانگی ایمکس" href="http://www.gnu.org/software/emacs/emacs.html" target="_blank"&gt;Gnu Emacs&lt;/a&gt;! آن بیرون چند توزیع مختلف ایمکس وجود دارد. ما در این‌جا موضوع بحث‌مان فرزند خلف ریچارد استالمن Gnu Emacs است که قابلیت نصب روی پلتفرم‌های مختلف‌، از جمله ویندوز را دارد. پس نیاز نیست که بترسید. البته مطمئنم اگر هنوز جرات نکرده‌اید از دمپایی ابری مایکروسافت جدا شوید‌، جرات سوئیچ به هیولایی مثل ایمکس را هم نخواهید داشت. هر چند که ایمکس در ویندوز هم می‌تواند زندگی‌تان را عوض کند. ;-)&lt;/li&gt;
    &lt;li&gt;من هم ایمکس نمی‌دانم‌! ساده است. حدودا یک سالی می‌شود که از ایمکس استفاده می‌کنم‌، ولی حتی تا همین یکی دو هفته پیش همیشه با ترسی قلمبه به سراغش می‌رفتم. اما یک جور‌هایی الان احساس می‌کنم به جایی رسیده‌ام که می‌توانم بهتر از ایمکس کار بکشم.&lt;/li&gt;
    &lt;li&gt;قرار نیست در این‌جا ایمکس یادتان بدهم‌! این یکی حتی از قبلی ساده‌تر است. برای یادگیری ایمکس‌، هیچ منبعی بهتر از خود ایمکس نیست! چطور؟ خیلی ساده‌، ایمکس‌تان را باز کنید و &lt;strong&gt;C-h t&lt;/strong&gt; را وارد کنید. اگر خیلی خیلی تازه‌کارید این دستوری که نوشتم یعنی‌، کلید Ctrl را پایین نگه دارید‌، h را نوازش کنید و سپس هر دو کلید را رها کرده و t را یک بار فشار دهید. ساده بود؟ آماده باشید که با یکی از هیجان‌انگیز‌ترین آموزش‌های عمرتان روبرو شوید (دروغ گفتم‌، احتمالا خیلی خیلی برای‌تان خسته کننده خواهد بود. چون احتمالا فکر می‌کنید که خیلی از این کار‌ها را با Visual Studio یا چه می‌دانم یک ادیتور دیگر که الان استفاده می‌کنید‌، خیلی راحت‌تر انجام می‌دهید. ولی اگر به من اعتماد دارید‌، باور کنید که اشتباه می‌کنید.).&lt;/li&gt;
    &lt;li&gt;این آموزش که انگلیسی است‌! دقیقا‌! شاید فکر کنید که با ترجمهٔ این آموزش بهتر می‌توانستم کمک کنم. ولی نه‌، آن‌قدر چیز برای یادگرفتن در مورد ایمکس به زبان انگلیسی وجود دارد‌، آن‌قدر نیاز به کمک گرفتن از ایمکس خواهیم داشت‌، آن‌قدر راهنماهای خوب در ایمکس وجود دارد که اگر تا الان انگلیسی‌تان داغان است‌، فکری به حال بهبودش بکنید. نیازی هم به کلاس‌ها و کتاب‌های گران‌قیمت ندارید. همین راهنما را باز کنید و شروع به خواندنش کنید. هر وقت هر جایی گیر کردید‌، با یک دیکشنری ترجمه را پیدا کنید. اوائل کمی سخت است‌، ولی هر چه جلوتر که می‌روید‌، به این شیوهٔ یادگیری بیشتر وابسته می‌شوید و لذت می‌برید ;-)&lt;/li&gt;
    &lt;li&gt;اگر ایمکس یاد نمی‌دهی‌، پس این پست‌هایت به درد چه می‌خورد؟ خوب منظورم از آن بند این بود که چیز‌های پایه‌ای را خودتان باید یاد بگیرید. من در این پست‌ها سعی دارم جاهایی را نشان‌تان دهم که در تخیل‌تان هم نمی‌گنجد.&lt;/li&gt;
    &lt;li&gt;چرا پست‌های سریالی؟ خوب ایمکس خیلی گنده است. خیلی خیلی کار می‌تواند انجام دهد. نوشتن یک کتاب ۱۰۰۰ صفحه‌ای هم نمی‌تواند شما را با همهٔ نادیده‌های‌تان آشنا کند. اما پست‌های کوتاه‌، که هم اشاره به نحوهٔ تنظیم قابلیت‌ها و هم اشاره به ویژگی‌های‌شان دارد‌، می‌تواند هم اشتیاق استفاده از آن‌ها را ایجاد کند و هم وقت کافی برای تجربه‌شان بدهد ;-)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;دیگر ادامه نمی‌دهم‌، همین‌قدر هم برای یک مقدمه کافیست. البته مطمئنم که C-h t برای‌تان مقدمهٔ خیلی خیلی بهتری خواهد بود. پس درنگ نکنید و به سراغش بروید ;-)&lt;/p&gt;</description><category>elisp</category><category>Emacs</category><category>ادیتور</category><category>ایمکس</category><category>ایمکس</category><category>برنامه نویسی</category><category>دوره</category><category>نرم افزار</category><category>ویندوز</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13920107yn-ymkhs-dwst-dshtny-mqdmh.html</guid><pubDate>Wed, 27 Mar 2013 09:09:34 GMT</pubDate></item><item><title>چگونه ایمکس‌مان را تربیت کنیم (قسمت دوم)</title><link>http://shahinism.github.io/posts/blog13910502chgwnh-ymkhsmn-r-trbyt-khnym-qsmt-dw.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;a title="چگونه ایمکس‌مان را تربیت کنیم (قسمت اول)" href="http://shahinism.com/blog/1391/04/23/%da%86%da%af%d9%88%d9%86%d9%87-%d8%a7%db%8c%d9%85%da%a9%d8%b3%e2%80%8c%d9%85%d8%a7%d9%86-%d8%b1%d8%a7-%d8%aa%d8%b1%d8%a8%db%8c%d8%aa-%da%a9%d9%86%db%8c%d9%85-%d9%82%d8%b3%d9%85%d8%aa-%d8%a7%d9%88/" target="_blank"&gt;در قسمت قبل&lt;/a&gt; نکات ساده و پایه‌ای را بیان کردیم و یک کلید ساده را جایگزین کلید قبلی پرش به پنجرهٔ بعدی کردیم‌. در این قسمت می‌خواهیم کمی هیجان کار را بالا ببریم‌.
&lt;h5&gt;این آرگومان‌های دوست داشتنی&lt;/h5&gt;
&lt;p&gt;یکی از اجزای جدا نشدنی توابع برنامه نویسی‌، آرگومان‌هایی هستند که می‌توان با استقاده از آن‌ها کارکرد توابع را تحت تاثیر قرار داد‌. توابع ایمکس هم از این قائده مستثنا نیستند‌. برای مثال می‌توان با C-u 3 C-x C-n نشانگر را به سه پنجره بعد از پنجرهٔ حاضر منتقل کرد‌. می‌خواهید امتحان کنید؟ ایمکس‌تان را باز کنید و آن را به چهار پنجره تقسیم کنید و فرمان بالا را وارد کنید‌. همان‌طور که می‌بینید تابع other-window که در این‌جا مورد بحث ماست‌، با استفاده از آرگومان دریافتی توسط C-u که همان عدد سه است‌، می‌تواند به سه پنجره بعد بپرد و ما را از فراخوانی پیاپی‌اش نجات دهد‌. حالا نکته این‌جاست که این تابع آرگومان منفی‌ای مثل ‎-۱ را هم می‌پذیرد‌. و احتمالا این دقیقا همان چیزی است که ما برای حرکت در پنجره‌ها به سمت چپ نیاز داریم‌. یک بار امتحانش کنید: C-u -1 C-x C-n&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;نکته:&lt;/strong&gt; اکثر توابع موجود در ایمکس با استفاده از مقادیری مثل ‎-۱ عکس عمل عادی‌شان را انجام می‌دهند‌. فکر کنید که با این ترکیب چه توابع جالب و کاربردی‌ای می‌توان ساخت‌. مثلا کلید delete عقب‌گرد که در ایمکس به طور عادی تعریف نشده D: (در آینده یک نمونه خواهیم ساخت ;-))&lt;/p&gt;
&lt;h5&gt;تعریف اولیه other-window-backward&lt;/h5&gt;

&lt;p&gt;برای این که از سختی وارد کردن همچون دستوری بکاهیم‌، بهتر است که آن را به صورت یک تابع تعریف کنیم تا هر جایی که نیاز بود بتوانیم به راحتی از آن استفاده کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;defun other-window-backward &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="s2"&gt;"Select the previous window."&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;interactive&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;other-window -1&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب این خطوط به چه معناست؟ به ترتیب آن‌ها را بررسی می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;defun other-window-backward &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در این خط مثل اکثر زبان‌های برنامه‌نویسی دیگر‌، شروع به تعریف تابع می‌کنیم‌. defun عبارتی است مانند def در پایتون که وظیفهٔ تعریف توابع را بر عهده دارد‌. در ادامه نیز اسم تابع other-window-backward و یک جفت پرانتز خالی (که محل تعریف آرگومان‌هایمان در آینده است) را قرار می‌دهیم‌.&lt;/p&gt;
&lt;p&gt;در خط دوم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="s2"&gt;"Select the previous window"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;تنها یک توضیح کوتاه برای عملکرد تابع می‌نویسیم‌. این توضیح عملا تاثیری در روند اجرا تابع ندارد‌. اما وقتی کاربر بخواهد با دستوری مثل describe-function از نحوهٔ عملکرد تابع مطلع شود‌، این توضیح است که نمایش داده می‌شود‌.&lt;/p&gt;
&lt;p&gt;خط سوم شامل:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;interactive&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;این خط در واقع بر نوع عملکرد تابع نسبت به آرگومان‌ها در زمان فراخوانی‌شان دلالت می‌کند‌. در ادامه با مزایای این دستور بیشتر آشنا خواهیم شد‌. فعلا الاالحساب آن را همانطور که هست وارد می‌کنیم‌.&lt;/p&gt;
&lt;p&gt;و خط آخر:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;other-window -1&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همان‌طور که معلوم است‌، تابع other-window آشنایمان را با آرگومان ‎-۱ صدا می‌کند‌. این آرگومان منفی همانطور که توضیح دادیم به تابع می‌فهماند که باید عقب‌گرد حرکت کند‌.&lt;/p&gt;
&lt;p&gt;حالا دیگر تقریبا کارمان تمام است‌. تنها کافی است که آن را به کلید ترکیبی مد نظرمان (C-x C-p چنان که در قسمت قبل تصمیم گرفتیم) پیوند دهیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;global-set-key &lt;span class="s2"&gt;"\C-x\C-p"&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;other-window-backward&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و کار تقریبا تمام است‌.&lt;/p&gt;
&lt;h5&gt;افزودن مزایای آرگومان‌ها&lt;/h5&gt;

&lt;p&gt;تا این‌جای کار other-window-backward کاری که می‌خواهیم را درست انجام می‌دهد‌. اما هنوز یک کمبود دارد‌. کدام کمبود؟ همانطور که بالا‌تر توضیح دادم ما می‌توانستیم با C-u به other-window بگوییم که مثلا به دو پنجره بعد بپرد و ما را از فراخوانی دوباره و دوباره‌اش نجات دهد‌. اما تابعی که الان تعریف کردیم‌، این قابلیت را ندارد‌. در نتیجه کاربر بخت برگشته باید برای پرش به سه پنجره قبل سه بار این کلید‌ها را فشار دهد‌! و این یعنی عذاب ;-)&lt;/p&gt;
&lt;p&gt;برای این که تابع‌مان یک آرگومان بپذیرد‌، آن را به شکل زیر ویرایش می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;defun other-window-backward &lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="s2"&gt;"Select Nth previous window."&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;interactive &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;other-window &lt;span class="o"&gt;(&lt;/span&gt;- n&lt;span class="o"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همانطور که می‌بینید در خط اول‌، یک آرگومان به لیست آرگومان‌های تابع به اسم n اضافه کردیم‌. با این کار به تابع فهماندیم اگر کاربر با C-u آرگومانی را فرستاد (مثلا ۲) آن را در متغیر n قرار بده‌.&lt;/p&gt;
&lt;p&gt;همینطور در خط آخر به جای استفاده از ‎-۱ تابع other-window را با آرگومان منفی n صدا زدیم‌. یعنی هر عددی به n فرستاده شد‌، به ترکیب فوق‌، به صورت منفی به other-window فرستاده می‌شود‌.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;توجه:&lt;/strong&gt; به فاصلهٔ میان علامت منفی و حرف n توجه کنید‌. در صورتی که بخواهید آن را به صورت:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;-n&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;بنویسید‌، مفسر لیسپ به مشکل بر می‌خورد‌. احتمالا یادتان هست که برای تفریق دو عدد چه کار باید می‌کردیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;- 2 6&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;لیسپ در این‌جا دو عدد را از هم کم می‌کند‌، اما اگر به جای دو عدد فقط یک عدد وجود داشته باشد‌، مثل تابع ما‌، آن را به صورت عدد منفی تلقی می‌کند‌.&lt;/p&gt;
&lt;p&gt;اما یک نکتهٔ مهم و اساسی در خط سوم وجود دارد که باید به آن نیز بپردازیم‌. ما در این خط به صورت زیر عمل کردیم‌:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;interactive &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;جریان آن p مشکوک چیست؟ اگر تابع مثل روش اول‌مان‌، هیچ آرگومانی نگیرد‌، interactive هم بدون آرگومان می‌ماند‌. اما اگر مثل روش اخیرمان بخواهیم در تابع از آرگومانی استفاده کنیم‌، باید یک آرگومان به صورت رشته کد به interactive هم اضافه کنیم‌. کد p کوچک به تابع می‌فهماند که اگر یک آرگومان به تابع فرستاده شد آن را به صورت یک عدد ترجمه کن و به تابع برگردان‌. اما اگر آرگومانی فرستاده نشد‌، خودت به صورت پیش‌فرض عدد ۱ را به تابع برگردان‌. و این دقیقا کاری است که ما تا این‌جای کار از تابع‌مان می‌خواهیم‌.&lt;/p&gt;
&lt;h5&gt;اختیاری کردن آرگومان&lt;/h5&gt;

&lt;p&gt;همان‌طور که می‌بینید‌، این تابع قابلیت فراخوانی توسط توابع دیگر لیسپ را نیز دارد‌. اما در این وضعیت (منظورم در حالتی است که تابع توسط توابع دیگر فراخوانده شود و نه در صورتی که توسط کاربر صدا زده می‌شوند) حتما باید به همراه فراخوانی تابع یک آرگومان هم به آن اطلاق شود‌. و این کمی کار را پیچیده می‌کند و ممکن است در آینده خسته کننده به نظر بیاید‌. بهتر است تابع را طوری تعریف کنیم که وقتی به صورت other-window-backward صدا شد خودکار روش انجام کار پیش‌فرضش را پیش بگیرد‌. پس آن را به صورت زیر ویرایش می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;defun other-window-backward &lt;span class="o"&gt;(&lt;/span&gt;&amp;amp;amp;optional n&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="s2"&gt;"Select Nth previous window."&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;interactive &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;n

&lt;span class="o"&gt;(&lt;/span&gt;other-window &lt;span class="o"&gt;(&lt;/span&gt;- n&lt;span class="o"&gt;))&lt;/span&gt; ; &lt;span class="k"&gt;if &lt;/span&gt;n is non-nil

&lt;span class="o"&gt;(&lt;/span&gt;other-window -1&lt;span class="o"&gt;)))&lt;/span&gt; ; &lt;span class="k"&gt;if &lt;/span&gt;n is nil
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;در خط اول با ‏‎&amp;amp;optional به تابع می‌فهمانیم که آرگومان n باید اختیاری باشد‌. یعنی اگر فرستاده شد مقدار دهی شود و اگر نه‌، بی‌خیالش باشد‌. همچنین از یک عبارت کنترلی if هم استفاده کردیم‌. در این عبارت اگر n مقدار داشته باشد‌، پس if با یک وضعیت non-nil یا همان True در اکثر زبان‌های برنامه نویسی روبروست‌. و اگر مقدار نداشته باشد‌، برابر است با nil یا False. با توجه با کامنت‌های موجود در کد احتمالا می‌توانید بفهمید که در صورت وقوع هر یک از این وضعیت‌ها کدام حالت رخ خواهد داد‌.&lt;/p&gt;
&lt;p&gt;فکر می‌کنم تا این‌جای کار برای امروز کافی باشد‌. کارمان هنوز با این تابع تمام نشده‌. هنوز کمی دیگر راه باقی است که بتوان آن را به عنوان یک تابع ایمکس لیسپی کامل قبول کرد‌. اما لازم است قبل از توضیح بیشتر و سخت کردن کار‌، مفاهیم گفته شده تا این‌جای کار کاملا درک شوند‌.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;پی‌نوشت:&lt;/strong&gt; مرا به علت دیر‌کرد این چند وقته در انتشار ادامهٔ مطلب حاضر ببخشید‌. امروز هم احتمالا نتوانسته‌ام آن‌طور که باید و شاید حق مطلب رو عدا کنم‌. حقیقتش امروز از آن روز‌هایی بود که در مود نوشتن برای وبلاگ نبودم ولی باید حتما تا این‌جای کار را بیان می‌کردم تا نوشته‌ها از خودم عقب نمانند ;-)&lt;/p&gt;</description><category>elisp</category><category>Emacs</category><category>emacs keybinding</category><category>lisp</category><category>ایمکس</category><category>ایمکس</category><category>برنامه نویسی</category><category>حل مشکل</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13910502chgwnh-ymkhsmn-r-trbyt-khnym-qsmt-dw.html</guid><pubDate>Mon, 23 Jul 2012 18:12:34 GMT</pubDate></item><item><title>چگونه ایمکس‌مان را تربیت کنیم (قسمت اول)</title><link>http://shahinism.github.io/posts/blog13910423chgwnh-ymkhsmn-r-trbyt-khnym-qsmt-w.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;h4&gt;مقدمه&lt;/h4&gt;
اصولا اگر خوانندهٔ این وبلاگ باشید می‌دانید که بعضی وقت‌ها هیجان زده می‌شوم و از روی ذوق نرم‌افزاری را انتخاب می‌کنم و پشت سر هم از جزئیاتش اینجا می‌نویسم تا دیگر از آن حرارت اولیهٔ آشنایی با آن بیافتم و بگذارمش کنار‌. ولی خوب خوبی‌اش این می‌شود که همیشه یک آرشیو دم دستی از چیز‌هایی که یاد می‌گیرم کنار دستم دارم. 
&lt;p&gt;احتمالا هم دیگر معلوم است که چند وقتی است دارم عادت می‌کنم که با ایمکس کار کنم‌. شاید برای باقی ملت این هم جزء همان جو گرفتن‌های اولیه باشد‌. ولی این بار این‌طور نیست‌. موضوع ناموسی شده‌! بیشتر از تمام نرم‌افزار‌هایی که در طول عمرم با آن‌ها سر و کار داشته‌ام‌، دوست دارم با ایمکس کار کنم‌. ولی این یکی تمام دانسته‌هایم را‌، عادت‌هایم را‌، علایقم را‌، بود و نبودم را به چالش می‌کشد‌! چطور؟ در این‌جا با نرم‌افزاری طرف هستم که بسیاری چیز دارد که من نمی‌خواهم‌، و بسیاری چیز دیگر ندارد که من می‌خواهم‌، (که دقیقا عکس همین عبارت هم صادق است). حالا نکته‌اش این‌جاست که این نرم‌افزار این قابلیت را به من می‌دهد که تبدیلش کنم به همان چیزی که می‌خواهم‌! چطور؟ elisp‌! &lt;/p&gt;
&lt;p&gt;در این مدت دو سه ماهه که با ایمکس سر و کله زده‌ام‌، منابعی یافته‌ام (که در پست بعدی سعی می‌کنم معرفی‌شان کنم) که کمکم کرده تا اندکی این زبان و تنظیمات (زیادزیادزیاد) ایمکس را درک کنم‌. همین درک اندک کلی هیجان هم برایم به همراه آورده‌. این است که می‌خواهم تا تمام شدن دوره کردن این منابعم‌، هر چیزی که به نظرم جالب و کاربردی می‌آید را تحت یک سری مقاله منتشر کنم‌. باشد که برای آیندگان مفید واقع شود ;-)&lt;/p&gt;
&lt;h4&gt;پیشنیاز&lt;/h4&gt;

&lt;p&gt;من این‌طور فرض می‌کنم که خوانندهٔ عادی این متن تا الان حداقل کلید‌های میانبر ایمکس را حفظ کرده‌، بلد است Frame کدام است‌، یا چطور بین پنجره‌ها جابجا شود یا پکیجی نصب کند‌! در این‌جا قرار است ما یاد بگیریم که چطور پکیج‌های خودمان را بسازیم ;-)&lt;/p&gt;
&lt;h5&gt;یک نکته&lt;/h5&gt;

&lt;p&gt;قرار نیست که در مورد هر دستوری که استفاده می‌کنم کامل توضیح دهم‌. گاهی می‌شود که تنها به یک توضیح کوتاه و نشان دادن عملکرد دستور بسنده می‌کنم‌. این‌طوری سعی دارم که بیشتر تمرکز را بگذارم روی هدف اصلی مطلب.&lt;/p&gt;
&lt;h4&gt;ساختار دستورات elisp&lt;/h4&gt;

&lt;p&gt;اولین نکته در مورد لیسپ (یا در این مورد elisp) این است که تمامی دستوراتش باید داخل پرانتز نوشته شود‌. یعنی فرمی به صورت زیر:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;command&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;نکتهٔ بعد نوع نوشتن دستورات است‌. در زبان‌هایی مانند C یا Python یا دیگر زبان‌هایی که تا الان دیده بودم‌ (جز اسمبلی) دستورات تقریبا به صورت عامیانه نوشته می‌شد‌. مثلا ۲ + ۳ را دقیقا همینطور می‌نوشتیم‌. ولی در لیسپ باید این ترتیب رعایت شود:‌ ۱- عملگر ۲- آرگومان‌ها‌. یعنی برای دستور ۲ + ۳ داریم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;+ 2 3&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب مزیتش می‌شود این که دیگر برای ۲ + ۳ + ۴ + ۵ + ۶ فقط می‌نویسیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;+ 2 3 4 5 6 &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و دیگر خبری هم از دردسر اولویت عملگر‌ها نمی‌شود‌. مثلا:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;+ 3 &lt;span class="o"&gt;(&lt;/span&gt;* 4 5&lt;span class="o"&gt;))&lt;/span&gt; که جوابش می‌شود ۲۳

&lt;span class="o"&gt;(&lt;/span&gt;* &lt;span class="o"&gt;(&lt;/span&gt;+ 3 4&lt;span class="o"&gt;)&lt;/span&gt; 5&lt;span class="o"&gt;)&lt;/span&gt; که جوابش می‌شود ۳۵
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;یا مثلا اگر قرار بود قبلا تابعی را با آرگومان‌هایش به صورت زیر فرا بخوانیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;foo &lt;span class="o"&gt;(&lt;/span&gt;3 + 4, 5 + 6&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;الان کارمان به این صورت انجام می‌گیرد:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;foo &lt;span class="o"&gt;(&lt;/span&gt;+ 3 4&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;+ 5 6&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ساده بود؟‌ خوب نکتهٔ‌ بعدی لیست‌ها هستند‌. که به صورت زیر تعریف می‌شوند:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;hello there&lt;span class="o"&gt;)&lt;/span&gt; که لیست شامل دو نشانه است.

&lt;span class="o"&gt;(&lt;/span&gt;1 2 xyz &lt;span class="err"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; که لیستی شامل دو عدد و یک رشته است‌.

&lt;span class="o"&gt;(&lt;/span&gt;a &lt;span class="o"&gt;(&lt;/span&gt;b c&lt;span class="o"&gt;))&lt;/span&gt; که لیستی شامل یک نشانه و یک زیر لیست است‌.

&lt;span class="o"&gt;()&lt;/span&gt; که یک لیست خالی است‌.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب تنها نکته‌ای که باقی می‌ماند و از باقی نکته‌ها مهم‌تر است کامنت است‌! در لیسپ کامنت‌ها بعد از «;» نوشته می‌شوند‌. هر وقت این علامت ظاهر شد تا انتهای خط به عنوان کامنت توسط مفسر لیسپ کامنت طلقی شده و نادیده گرفته می‌شود‌.&lt;/p&gt;
&lt;p&gt;نکات پایه‌ای در مورد نحو لیسپ را تا این‌جای کار دیدیم‌. نکات ضریف‌تر و کاربردی‌تری هم وجود دارد که در ادامهٔ مقالات و وقتی به آن‌ها نیاز شد مطالعه‌شان می‌کنیم.&lt;/p&gt;
&lt;h4&gt;کلید‌ها در elisp&lt;/h4&gt;

&lt;p&gt;برای این که به ایمکس بفمانیم با فشرده شدن فلان کلید فلان کار را انجام بده‌، باید اول بدانیم که چطور یک کلید را تعریف کنیم‌. کلید‌ها در حالت عادی بین دو کتیشن "" و به صورت یک رشته تعریف می‌شوند‌. مثلا در مثلا زیر ما سه کلید xyz را تعریف می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="s2"&gt;"xyz"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;اما نکته این‌جاست که چطور کلید‌های Ctrl و Alt را به ایمکس حالی کنیم‌! این کلید‌ها عملا با حرف C بزرگ برای Ctrl و M برای کلید Meta یا همان Alt شناخته می‌شوند‌. اما اگر ما "M" یا "C" استفاده کنیم، حروف M بزرگ و C بزرگ را معرفی کرده‌ایم و نه Ctrl و Alt را‌. این‌جاست که از علامت شکنندهٔ «\» استفاده می‌کنیم‌. (اگر قبلا برنامه نویسی کرده باشید احتمالا خوب از مزایایش با خبرید‌). و داریم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="s2"&gt;"\M"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب دیگر کارمان راحت شد‌. فقط یک نکتهٔ کوچک دیگر باقی می‌ماند‌. این که چطور فرق بین پایین نگه داشتن کلید Ctrl و زدن x و بعد رها کردن هر دویشان و زدن مثلا کلید l را تعیین کنیم‌. این عبارت در ایمکس به صورت C-x l نوشته می‌شود‌. خوب احتمالا حدس زده‌اید‌:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="s2"&gt;"\C-x l"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;نکته&lt;/strong&gt;: برای نمایش کلید Esc به صورت "\e" و برای کلید Del از عبارت "\C-‎?‎" استفاده می‌کنیم.&lt;/p&gt;
&lt;h4&gt;امتحان تغییرات ایجاد شده روی ایمکس&lt;/h4&gt;

&lt;p&gt;خوب ما تغییرات و توابع ایجاد شده‌یمان را در فایل ‎.emacs موجود در پوشهٔ خانگیمان وارد می‌کنیم‌. اما چطور تغییرات را اعمال کنیم؟ ساده‌ترین راه و اولین چیزی که احتمالا به ذهنتان می‌رسد بستن ایمکس و باز کردن دوباره‌اش است. روش خوبی است‌‌، ولی آسان‌تر از این هم پیدا می‌شود‌. مثلا زدن دستور زیر:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;M-x &lt;span class="nb"&gt;eval&lt;/span&gt;-buffer RET
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;این دستور تقریبا کار راه انداز است‌. ولی موقعی که فایل کانفیگتان زیادی سنگین شد‌، و مثلا رسید به هزار خط (‌می‌رسد‌، غم مخورید ;-)) ممکن است زمان زیادی تا لود شدن طول بکشد‌. پس منطقی نیست که همهٔ فایل را لود کنیم‌. چطور است که فقط تغییرات ایجاد شده را دوباره لود کنیم؟ (همین انتخاب‌های گسترده است که دارد عاشق دل باخته‌ام می‌کند ;-)) پس راه بعدی‌مان می‌شود این که برویم در انتهای خطی که تغییر جدیدمان را اعمال کرده‌ایم بایستیم و کلید‌های زیر را وارد کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;C-x C-e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;کار این کلید‌ها این است که خط قبل از علامت نشانگر را پردازش کنند و در کانفیگ حاضر ایمکس مداخله دهند‌. &lt;/p&gt;
&lt;p&gt;خوب ما می‌دانیم که این کلید‌ها حتما یک دستوری را پشت پردهٔ ایمکس اجرا می‌کنند‌. می‌خواهید بدانید که آن دستور چیست؟ اول دستور زیر را وارد کنید:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;M-x describe-key
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و سپس کلید‌های ترکیبی‌تان را وارد کنید‌. یک توضیح کامل از دستور مورد استفاده در پنجره‌ای جدید روبرویتان ظاهر می‌شود‌.&lt;/p&gt;
&lt;p&gt;خوب دیگر بحث تئوری کافیست‌. بهتر است برویم سراغ کمی کار عملی‌. &lt;/p&gt;
&lt;h4&gt;حل مشکل پرش بین پنجره‌های ایمکس&lt;/h4&gt;

&lt;p&gt;مساله خیلی ساده است‌. تا به حال حتما پیش آمده که چند تا پنجرهٔ باز دارید و می‌خواهید بین‌شان سوئیچ کرده و به پنجرهٔ سمت راست‌تان بروید. خوب برای این کار از کلید‌های C-x o استفاده می‌کنید‌. حالا اگر بخواهید به سمت چپ بروید چطور؟ شاید وقتی دو پنجرهٔ باز دارید کار سختی نباشد و با تکرار همین دستور به سمت چپی هدایت شوید‌. ولی در پنج پنجرهٔ باز چطور؟ چهار بار باید این کار را انجام دهید‌. یا شاید اصلا نظرتان به نظر من نزدیک باشد که C-x o یک کمی را دست نباشد‌. (این نظر شخصیست) طی ادامهٔ این شماره از مقاله و شمارهٔ بعد قصد حل این مساله را داریم‌. یعنی اول این که کلید‌های C-x o که وظیفه‌شان پرش به پنجرهٔ بعدی است را با یک کلید دلخواه جایگزین کنیم‌. و سپس یک کلید که بتواند عکس همین عمل را یعنی پرش به پنجرهٔ سمت چپ را انجام دهد هم بسازیم‌.&lt;/p&gt;
&lt;p&gt;خوب تا این‌جای کار می‌دانیم چه کار‌هایی می‌توان انجام داد و می‌دانیم که چه مساله‌ای پیش رو داریم‌. پس حل تقریبا آسان است‌. پس شروع می‌کنیم‌. اولین کاری که باید بکنیم این است که بفهمیم با چه دستوری می‌توان یک کلید میانبر تعریف کرد‌. دستور مورد نظر ما global-set-key نام دارد‌. که به صورت زیر می‌تواند مورد استفاده قرار گیرد:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;global-set-key KEY COMMAND&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب حالا دو چیز بعدی که نیاز داریم هم سر و کله‌شان پیدا شد‌. اولی KEY که منظور کلید‌های میانبر مورد نظرمان است‌، و دیگری COMMAND که دستوری است که می‌خواهیم با زدن کلید‌های KEY اجرا شود‌. خوب چه کلید‌هایی را انتخاب کنیم؟ این کتابی که من به عنوان راهنما استفاده می‌کنم کلید‌های C-x C-n را برای پرش به پنجرهٔ سمت راست و C-x C-p را برای پرش به پنجرهٔ سمت چپ انتخاب کرده‌. انتخاب جالبی به نظر می‌رسد و من هم همان‌ها را انتخاب می‌کنم‌. اما نکته این‌جاست که اول ببینیم نکند یادمان نباشد و بزنیم یکی از کلید‌های میانبر حاضرمان را ناکار کنیم‌. پس می‌آییم و با describe-key ته و توی قضیه را می‌ریزیم روی دایره‌. هاها بعله‌، این کلید‌ها به ترتیب برای فراخوانی set-goal-column و mark-page استفاده می‌شوند‌. که خوب حتی روحم هم از وجود چنین چیز‌هایی خبر‌دار نبود‌. پس فکر نمی‌کنم که این تغییر اشکالی داشته باشد‌. ضمن این که هر وقت که بخواهم می‌توانم دستورام را بعد از M-x وارد و اجرا کنم D:. پس کلید‌ها هم تعیین شد و تا اینجای کار دستور مربوط به پرشمان به پنجرهٔ سمت راست چیزی شبیه به این شده:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;global-set-key &lt;span class="s2"&gt;"\C-x\C-n"&lt;/span&gt; COMMAND&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;و حالا بخش آخر داستان‌. حتما دیگر یاد گرفته‌اید که چطور دستور مربوط به C-x o را که می‌خواهیم به C-x C-n پیوند بدهیم را پیدا کنید‌. ما پیدایش کردیم و فهمیدیم که دستوری به اسم other-window را اجرا می‌کند‌. پس احتمالا می‌گویید که دستورمان بعد از تکامل می‌شود این:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;global-set-key &lt;span class="s2"&gt;"\C-x\C-n"&lt;/span&gt; other-window&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب تا حدودی راست گفته‌اید‌. ولی مشکل اینجاست که لیسپ کمی خنگ است و آن دستوری که سمت راست نوشته‌ایم other-window را هم اجرا می‌کند و این اصلا خوب نیست‌. پس باید یک جوری حالیش کنیم که بی‌خیال این دستور شود و فقط سمت چپی را اجرا کند‌. این است که یک «'» به تنهایی به کمکمان می‌آید و دستور می‌شود:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;global-set-key &lt;span class="s2"&gt;"\C-x\C-n"&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;other-window&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;همین کتیشن کوچک در ابتدای دستور از اجرای دستور دوم جلوگیری می‌کند و دستورمان کامل می‌شود‌. حالا می‌ماند که چطور به ایمکس بگوییم که از آن استفاده کند‌. خوب قبلا در موردش توضیح دادم‌. مثلا همین الان بروی به آخر خط همین دستور (C-e) و بزنید C-x C-e و تمام‌. حالا دستورتان را امتحان کنید‌. &lt;/p&gt;
&lt;p&gt;چیزی که باقی می‌ماند این است که کلید C-x C-p را تعریف کنیم تا پس از زدنشان به پنجرهٔ قبلی یا سمت چپی‌مان برود و چون این کار یک کمی پیچیده‌تر است بهتر است آن را برای قسمت بعد بگذاریم‌. قسمتی که شما تا این‌جای داستان را به درستی درک کرده‌اید ;-)&lt;/p&gt;</description><category>elisp</category><category>Emacs</category><category>emacs keybinding</category><category>lisp</category><category>ایمکس</category><category>ایمکس</category><category>برنامه نویسی</category><category>حل مشکل</category><category>نرم افزار</category><category>کدباز</category><guid>http://shahinism.github.io/posts/blog13910423chgwnh-ymkhsmn-r-trbyt-khnym-qsmt-w.html</guid><pubDate>Fri, 13 Jul 2012 19:34:31 GMT</pubDate></item><item><title>وقایع نگاری شخصی سازی emacs قسمت اول</title><link>http://shahinism.github.io/posts/blog13910406wqy-ngry-shkhsy-szy-emacs-qsmt-wl.html</link><description>&lt;p&gt;&lt;/p&gt;&lt;p&gt;هاهاها! ایمکس شده بلای جانمان‌! حقیقتش نه این که خیلی آش دهن سوزی باشدها‌، نه‌! لعنتی اعتیادش بالاست‌. یک بار که از میانبر‌هایش استفاده کنید دیگر همه‌جا می‌خواهید همین میانبر‌ها باشند‌. همهٔ برنامه‌ها را مثل آن می‌خواهید‌. دوست دارید همه چیزتان را همین لعنتی انجام دهد‌! آن‌قدر هم ابزار و چیز میز برای بازی کردن دارد که می‌توانید وقتتان را به خوبی پایش تلف کنید‌! زیاده‌گویی بس است و می‌رویم پی اصل ماجرا‌.
اول از همه این که emacsام را به نسخهٔ ۲۴ (بی‌خیال پیشوندش) ارتقا دادم که دو مزیت عمده داشت‌:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;اول&lt;/strong&gt; این که جهت چینش هر پاراگراف را مثل مرورگر‌های جدید بر اساس نوع نوشتار تعیین می‌کند‌. این یعنی متن فارسی را می‌توان مثل آدمی‌زاد درش نوشت و درد نگرفت‌!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;دوم&lt;/strong&gt; مدیر بسته‌هاست که کلی چیز جدید می‌تواند به emacsتان اضافه کند‌. بحث ما هم سر همین دومیست‌.&lt;/p&gt;
&lt;p&gt;ایمکس به صورت پیش‌فرض خیلی خوب است‌، خیلی‌. ولی می‌توان با دستکاری خیلی چیز بهتر و کارا‌تری هم از تویش در آورد‌. این است که می‌خواهم چند تا بسته برای کار‌هایم توش اضافه کنم‌. اما اول از همه باید یک مخزن درست و درمان به مدیر بسته‌هایم اضافه کنم تا برای نصب بسته‌ها درد کمتری متحمل شوم (بماند که خود این مدیر بسته کلی دردناک می‌شود به وقتش‌!). پس اگر فایل ‎.emacs در پوشهٔ خانگی‌ام ندارم یکی می‌سازم و به صورت زیر مخزن‌هایم را اضافه می‌کنم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;(&lt;/span&gt;setq package-archives &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="s2"&gt;"ELPA"&lt;/span&gt; . &lt;span class="s2"&gt;"http://tromey.com/elpa/"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"gnu"&lt;/span&gt; . &lt;span class="s2"&gt;"http://elpa.gnu.org/packages/"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"marmalade"&lt;/span&gt; . &lt;span class="s2"&gt;"http://marmalade-repo.org/packages/"&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;خوب گل سر سبد این مخازن اسمش &lt;a title="Marmalade repo" href="http://marmalade-repo.org/" target="_blank"&gt;Marmalade&lt;/a&gt; است که از &lt;a title="یادداشت‌های بیت نیمسوز" href="http://cyberrabbits.net/" target="_blank"&gt;فرود&lt;/a&gt; عزیز بابت معرفیش تشکر می‌کنم ;-). خوب بسته‌ها اضافه شد و کافیست بعد از باز کردن ایمکس کلید M + x را فشار دهیم‌. (M مخفف Meta است و منظور در اینجا کلید Alt و یا اگر نداریدش کلید Esc هست) و در اعلان ظاهر شده بنویسیم package-list-packages (اعلان ایمکس قابلیت Auto Completion دارد پس با Tab کارتان را در نوشتن دستوراتش راحت‌تر کنید). پس از مدتی انتظار لیستی از بسته‌های قابل نصب یا نصب شده روی سیستم‌تان نمایش داده می‌شود. نشانگر را روی هر بسته ببرید‌. Enter را فشار دهید تا توضیحاتش را بخوانید‌. اما فعلا بی‌خیال این بخش شوید و همراه من بیایید تا چند بستهٔ حیاتی به درد بخور را نصب کنیم:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cx4a.org/software/auto-complete/" target="_blank"&gt; &lt;strong&gt;Auto-complete:&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;اولین نیاز من برای یک ادیتور به درد بخور همین قابلیت تکمیل خودکار متن است‌. اول این که سرعتم را بالا‌تر می‌برد‌. دوم هم این که خیالم را در خطاهای املایی در برنامه‌نویسی راحت‌تر می‌کند ;-) این می‌شود که در ایمکس دستور زیر را وارد می‌کنم M + x package-install RET auto-complete و بسته نصب می‌شود‌. آن‌وقت فایل ‎.emacs را باز می‌کنم و خط‌های زیر را به آن اضافه می‌کنم‌:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;;;Start Auto-complete config

&lt;span class="o"&gt;(&lt;/span&gt;add-to-list &lt;span class="s1"&gt;'load-path "~/.emacs.d/elpa/auto-complete-1.4")&lt;/span&gt;

&lt;span class="s1"&gt;(require '&lt;/span&gt;auto-complete-config&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;add-to-list &lt;span class="err"&gt;'&lt;/span&gt;ac-dictionary-directories &lt;span class="s2"&gt;"~/.emacs.d/elpa/auto-complete-1.4/dict"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;ac-config-default&lt;span class="o"&gt;)&lt;/span&gt;

;;End Auto-complete config
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا عملا کار باید تمام شده باشد‌. اما یک مشکل وجود دارد که حدود دو سه ساعت وقتم را نابود کرد تا بفهمم از کجاست‌. بستهٔ Auto-complete برای نمایش دادن آن جعبهٔ خوشگلش برای کلمات پیشنهادی از یک بستهٔ دیگر به اسم popup استفاده می‌کند که خوشبختانه مدیر بسته‌ها هم این بسته را به عنوان پیش‌نیاز نصب می‌کند‌. اما در یک پوشهٔ جدا‌. حالا بستهٔ Auto-complete هر چه می‌گردد در پوشهٔ خودش نمی‌تواند popup.el را پیدا کند‌. این می‌شود که می‌نویسیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;cp ~/emacs.d/elpa/popup/popup.el ~/emacs.elpa/auto-complete-1.4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;حالا این بسته نصب شده و در همه‌جا فعال است‌. این بسته در شاخهٔ dict در محل نصبش یک سری فایل با شناسهٔ Modeهای مختلف ایمکس دارد که در واقع لغت‌های پیشنهادی را از آن‌جا می‌یابد‌. لغات در بعضی از دیکشنری‌های مخصوصا برای C+‎+‎ خیلی ناقص است‌. می‌توانید دستی فایل را باز کنید و کاملش کنید‌.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/bbatsov/zenburn-emacs" target="_blank"&gt;&lt;strong&gt;zenburn-theme:&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;این تم را &lt;a title="تغییر پوسته Emacs با بسته color-theme" href="http://shahinism.com/blog/1391/01/12/%d8%aa%d8%ba%db%8c%db%8c%d8%b1-%d9%be%d9%88%d8%b3%d8%aa%d9%87-emacs-%d8%a8%d8%a7-%d8%a8%d8%b3%d8%aa%d9%87-color-theme/" target="_blank"&gt;قبلا&lt;/a&gt; معرفی کرده‌ام‌. برای نصبش می‌نویسیم M + x package-install RET zenburn-theme RET و کار تمام است. حالا برای لود شدن این تم به صورت پیش‌فرض خطوط زیر را به ‎.emacs اضافه می‌کنیم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;;;Start: config theme

&lt;span class="o"&gt;(&lt;/span&gt;add-to-list &lt;span class="s1"&gt;'custom-theme-load-path "~/.emacs.d/elpa/zenburn-theme-1.5")&lt;/span&gt;

&lt;span class="s1"&gt;(load-theme '&lt;/span&gt;zenburn t&lt;span class="o"&gt;)&lt;/span&gt;

;;End: config theme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;این تم در حالت گرافیکی به راحتی لود می‌شود‌. اما در حالت متنی emacs -nw به خاطر کم بودن رنگ‌ها ممکن است مشکل داشته باشید‌. برای حل این مشکل فعلا الالحساب این خط را به فایل ‎.bashrc یا ‏‏‎.zshrc تان اضافه کنید تا بعدا در یک پست مجزا در موردش توضیح دهم:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;TERM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;xterm-256color
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;بعله‌. الان دیگر تمتان هم خیلی میزان است و همه‌جا قابل استفاده ;-)&lt;/p&gt;
&lt;p&gt;php-mode, &lt;a href="http://code.google.com/p/js2-mode/" target="_blank"&gt;js2-mode&lt;/a&gt;, css-mode:&lt;/p&gt;
&lt;p&gt;مهم‌ترین چیز برای برنامه‌نویس‌هایی که می‌خواهند از ایمکس برای توسعهٔ پروژه‌هایشان استفاده کنند همین مد‌های ایمکس هستند‌. در اینجا سه مد مختلف برای زبان‌های php, javascript و CSS معرفی شده‌اند که به نظرم خیلی عالی هستند‌. مخصوصا js2-mode که یک IDE به تمام معنا برایتان مهیا می‌کند‌! برای نصب که دیگر باید بدانید چه کار کنید‌. هیچ خطی هم نیاز نیست به ‎.emacsتان اضافه کنید‌. تنها برای رفتن به هر مد کافیست تایپ کنید M + x mode-name RET همین. فعلا برای قسمت اول کافیست‌. در قسمت بعد با چیز‌های هیجان‌انگیز‌تری بر می‌گردیم D:&lt;/p&gt;</description><category>auto-complete</category><category>css-mode</category><category>Emacs</category><category>js2-mode</category><category>php-mode</category><category>terminal 256 color</category><category>zenburn</category><category>ایمکس</category><category>نرم افزار</category><category>کدباز</category><category>گنو/لینوکس</category><guid>http://shahinism.github.io/posts/blog13910406wqy-ngry-shkhsy-szy-emacs-qsmt-wl.html</guid><pubDate>Tue, 26 Jun 2012 19:02:52 GMT</pubDate></item></channel></rss>