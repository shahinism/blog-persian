<html><body><p>از آب گل آلود ماهی گرفتن به این می‌گویند D:. به حول قوهٔ الهی و بعد از اول شدنمان در دنیا‌، سروری که از فرت آزادی بیان و عقیده از آن به عنوان چاقوی سوئیسی استفاده می‌کردیم‌، قیمتش ظرف یک دورهٔ یک ماهه‌، دو برابر شد‌ (تازه بماند که چقدر فروشنده پوست خربزه زیر بقلمان گذاشت که ضرر می‌کند). این شد که تصمیم گرفتیم سروری با منابع کمتر ابتیاع کنیم و خوب به خاطر این که نمی‌خواستیم به سرور بخت برگشته‌مان آن‌قدر فشار بیاوریم که زرتش در برود‌، تصمیم گرفتیم که بی‌خیال وب سرور شویم‌ (و البته کلی جینگولک دیگر)!
خوب این بی‌خیال شدن یعنی دیگر نمی‌توانستیم در نهایت گشادی فایل‌هایی که خیر‌خواهانه از سمت کشور‌هایی کاملا دموکراتیک و آزاد از دسترسمان خارج شده بود -تا مبادا خدای نکرده‌، بزنیم کسی را با آن اوخ کنیم- را دانلود کنیم روی سرور و بعد با وب سرور بخورانیم به دانلود منیجر همه فن حریفمان‌، همچین هم نمی‌شد اسم سرورمان را گذاشت چاقوس سوییسی D:

این شد که تصمیم گرفتم که راهی غیر از وب سرور برای انتقال فایل از سرور (که می‌توان دقیقا یک کامپیوتر با یک اتصال اینترنت به درد بخور فرضش کرد) به کامپیوتر خودمان پیدا کنم‌. در این مسیر همراهم باشید و عمرا قصه نخورید که چرا در سیستم عامل استکباریتان‌، خواب چنین وسایلی را به راحتی نمی‌بینیند:

</p><h4>Konqueror:</h4>

خوب اولین ابزار دم دستمان مرورگر پیش‌فرض KDE است‌. برای دیدن فایل‌های روی وب‌سرور تنها کافیست در آدرس‌بار چنین چیزی بنویسیم:

```bash

fish://USER@IPSERVER

```

خودش پس از شروع به جستجو پسوورد می‌پرسد که همان پسوورد ssh (پسوورد یوزر) خواهد بود‌. و دیگر می‌توانید با فایل‌ها جوری رفتار کنید که انگار روی کامپیوتر خودتان قرار دارند‌. ولی خوب بدیهی است که با سرعت اینترنت بالای ما‌، خیلی دردناک است‌. برای فایل‌های کوچک حداکثر تا دو سه مگابایتی می‌توان با یک کپی پیست ساده سر و ته قضیه را هم آورد‌. ولی اگر فایل دو گیگ باشد‌، باید دنبال چارهٔ بهتر گشت‌.

<h4>scp</h4>

یا همان Safe CoPy‌، که به این صورت مورد استعمال قرار می‌گیرد:

```bash

scp USER@IPSERVER:PATH_TO_FILE _Path_to_download_

```

بعد از اجرا یک پرامپتی می‌آید و پسوورد می‌پرسد (عین ssh خودمان) و عملیات کپی انجام می‌شود‌. بدبختی‌اش این‌جاست که چون ما خیلی به سرعت انتقالمان اطمینان داریم‌، یک بار زبانم لال، فایلمان ناقص دانلود شود‌ (لنگر است دیگر‌، می‌افتد‌)، دیگر نمی‌توان Resume‌اش کرد و باید دوباره از اول شروع کنید‌.

scp خوب است‌، ولی باز هم زیاد به درد موقعیت ما نمی‌خورد‌. می‌رویم گزینهٔ بعدی.

<h4>Filezilla</h4>

این فایلزیلای پدر سوخته را احتمالا از روی استفاده‌هایش برای FTP می‌شناسید‌. خوب خوشبختانه این‌ها از پروتکلی به اسم SFTP هم پشتیبانی می‌کنند که منظورش این است که SSH می‌تواند برای وصل شدن به سرور مقصد قرار گیرد‌. پس کافیست از منوی فایل روی Site manager کلیک کنید و صفحهٔ باز شده را مثل عکس زیر کانفیگ کنید:

<p style="text-align: center;"><a href="http://dl.dropbox.com/u/25017694/Blog-photos/filezilla.png"><img class="aligncenter" title="Filezilla site manager" src="http://dl.dropbox.com/u/25017694/Blog-photos/filezilla.png" alt="Filezilla site manager" width="419" height="331"></a></p>

و بعد هم روی connect بزنید و تمام‌. خیلی راحت وصل می‌شوید و می‌توانید با Drog &amp; Drop فایل را انتقال دهید به سیستم‌تان‌. آسان بود‌. ولی خوب ما فقیر فقرا که ساعت ۲ تا ۷ صبح سرعت اینترنت‌مان سر به فلک می‌کشد‌، با تک نخی بودن مدل دانلود‌مان احتمالا طی پنج ساعت نمی‌توانیم ۲ درصد یک فایل دو گیگی را دانلود کنیم‌. می‌توانیم؟

پس فایلزیلا هم با تمام خوبی‌هایش بهتر است برود جلو بوق بزند‌. ما باید برای مساله‌مان دنبال یک راه حل بهتر باشیم‌.

<h4>rsync</h4>

یاد‌تان می‌آید گفتیم که scp سرعت خوبی داشت ولی Resume نمی‌کرد‌. یک ابزار دیگر هم داریم که جینگولک بازی‌هایش در زمان Resume فوق‌العاده است و زبان زد خاص و عام‌. مثل این نقل قول:

<blockquote>ای کسانی که ویندوز آورده‌اید‌، اگر راست می‌گویید rsync بیاورید «<del>منبع نامعلوم</del><a href="http://shahinism.com/blog/1391/07/26/%d8%b3%db%8c%d8%b1-%d8%b5%d8%b9%d9%88%d8%af%db%8c-%d9%88-%d8%b1%d9%88%d8%b4%e2%80%8c%d9%87%d8%a7%db%8c-%d9%85%d8%ae%d8%aa%d9%84%d9%81%db%8c-%da%a9%d9%87-%d8%a8%d8%b1%d8%a7%db%8c-%d8%af%d8%a7%d9%86/#comment-537"> منبع خودش اومد اعتراف کرد ;-)</a>»</blockquote>

این می‌شود که از آن به صورت زیر استفاده می‌کنیم:

```bash

rsync -az --progress --rsh='ssh' --partial USER@IPSERVER:PATH_TO_FILE _Path_to_download

```

خیلی هم خوب‌. یکی از ویژگی‌هایش این است که می‌توانید آدرس یک پوشه را برای دانلود بهش بخورانید و دیگر دست به دستور نزنید و فقط هر وقت خواستید رانش کنید‌. خودش آخرین فایل‌های آن پوشه را می‌گیرد‌. اما امان از سرعت‌. این جینگولک بازی‌های rsync روی قابلیت‌های فوق‌العاده resume‌اش هزینه دارد و آن هم سرعت است‌! که ما به آن هم خیلی نیاز داریم‌. برای این کار بسته به موقعیت می‌توانیم آن آرگومان z را حذف کنیم‌. ولی حقیقتش برای ما فرق چندانی نداشت‌.

این است که rsync هم می‌گذاریم برای وقتی که لازمش داریم و می‌رویم دنبال یک راه حل بهتر که هم Resume کند‌، هم چند نخه دانلود کند‌، و از آن مهم‌تر این که هی مجبورمان نکند پسوورد بزنیم! آخر چه کسی حالش را دارد ساعت ۲ صبح پسوورد یادش بیاورد؟

<h4>lftp</h4>

فوق‌العاده‌ است‌. فوق‌العاده‌. و این‌طوری استفاده می‌شود:

```bash

lftp -c "mirror -c --use-pget-n=10 --verbose sftp://USER:PASSWORD@IPSERVER/PATH_TO_FILE"

```

هوم‌، یک کمی طولانی شد‌. ولی بگذارید کمی در موردش صحبت کنیم‌. چون واقعا لازم به توضیح است:

<ul><li>‎-c اول یعنی این که دستور روبرو را اجرا کن‌.</li>
	<li>mirror یک برنامه توکار برای lftp است‌. یکی دیگر مثلا pget است‌. هر کدام به درد جایی می‌خورد و این mirror الان به درد ما‌. (از pget هم می‌توان استفاده کرد ولی این یکی بیشتر به مزاقم نشست).</li>
	<li>‎-c این آرگومان مال mirror است و یعنی Resume کن اگر می‌توانی D:</li>
	<li>‎--user-pget-n=10 یعنی فایل را ده قسمت کن و همه را با هم بگیر‌. این همان قابلیت چند نخی است که باعث افزایش سرعت می‌شود و دانلود منیجر‌های مدرن با آن پز می‌دهند ;-)</li>
	<li>USER:PASSWORD یعنی این‌ور یوزر را می‌نویسیم و آن‌ورش رمز عبورش را!</li>
	<li>PATH_TO_FILE این‌بار کمی با باقی مواقع فرق دارد‌. قبلا آدرس را از پوشهٔ خانگی یوزری که وارد شده بود وارد می‌کردیم و موضوع حل بود‌. ولی اینجا آدرس را از ریشه (/) می‌نویسیم‌. یعنی اگر در پوشهٔ خانگی‌تان است می‌شود این:</li>
</ul>

```bash

/home/USER/File

```

lftp هم مانند rsync (شاید هم scp) زورش را دارد که پوشه‌ای که به آن خورانده‌ایم را دانلود کند‌.

همین دیگر‌. دیدید؟ باز هم بگویید بد است‌. لامصب را می‌بینید که چقدر به فکر جیب آدم است؟ با هر پولی و با هر سازی که دلتان خواست برایش بنوازید‌، برای‌تان آن‌قدر خوب رقص می‌کند که انگشت به دهن می‌بانید ;-)</body></html>
